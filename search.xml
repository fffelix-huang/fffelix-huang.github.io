<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSDN 博客登入後複製解決方法</title>
      <link href="/posts/csdn-copy/"/>
      <url>/posts/csdn-copy/</url>
      
        <content type="html"><![CDATA[<p>CSDN 博客每次都會要求登入後複製，非常麻煩。只需要在按下 <code>F12</code> 進入 console 後貼上以下的指令即可。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">javascript</span>:<span class="hljs-variable language_">window</span>.<span class="hljs-property">oncontextmenu</span>=<span class="hljs-variable language_">document</span>.<span class="hljs-property">oncontextmenu</span>=<span class="hljs-variable language_">document</span>.<span class="hljs-property">oncopy</span>=<span class="hljs-literal">null</span>; [...<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'body'</span>)].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">dom</span> =&gt;</span> dom.<span class="hljs-property">outerHTML</span> = dom.<span class="hljs-property">outerHTML</span>); [...<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'body, body *'</span>)].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">dom</span> =&gt;</span> {[<span class="hljs-string">'onselect'</span>, <span class="hljs-string">'onselectstart'</span>, <span class="hljs-string">'onselectend'</span>, <span class="hljs-string">'ondragstart'</span>, <span class="hljs-string">'ondragend'</span>, <span class="hljs-string">'oncontextmenu'</span>, <span class="hljs-string">'oncopy'</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> dom.<span class="hljs-title function_">removeAttribute</span>(ev)); dom.<span class="hljs-property">style</span>[<span class="hljs-string">'user-select'</span>]=<span class="hljs-string">'auto'</span>;});<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 22.04 音量控制按鈕消失解決方法</title>
      <link href="/posts/ubuntu-volume-button-disappear/"/>
      <url>/posts/ubuntu-volume-button-disappear/</url>
      
        <content type="html"><![CDATA[<p>今天不知道不小心動了什麼東西導致音量控制的按鈕消失，畫面如下圖</p><p><img src="/posts/ubuntu-volume-button-disappear/ubuntu-volume-button-disappear.png" alt="Ubuntu 音量控制按鈕消失"></p><p>此情況甚至連鍵盤快捷鍵 <code>Fn + 右鍵</code> 都沒辦法控制音量。</p><p>爬了很多文章甚至重新灌了 kernel 都沒有解決問題，後來發現了一個簡單的指令就能讓它顯示。</p><p>打開 terminal 打上以下指令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pulseaudio --start<br></code></pre></td></tr></tbody></table></figure><p>大功告成！</p><p><img src="/posts/ubuntu-volume-button-disappear/ubuntu-volume-button-appear.png" alt="Ubuntu 音量控制按鈕出現"></p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>狂賭之淵中的吉爾布雷斯洗牌法 (Gilbreath&#39;s Shuffle)</title>
      <link href="/posts/gilbreath-shuffle/"/>
      <url>/posts/gilbreath-shuffle/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在看狂賭之淵，其中第二季第四集中提到「吉爾布雷斯洗牌法」，因為覺得蠻有趣的因此特別寫這篇文章紀錄。</p><h2 id="吉爾布雷斯洗牌法"><a href="#吉爾布雷斯洗牌法" class="headerlink" title="吉爾布雷斯洗牌法"></a>吉爾布雷斯洗牌法</h2><p>以下我們用動漫中的例子。</p><p>這副牌由 $0 \sim 3$ 組成，一共 $40$ 張，牌的初始順序為 $0, 1, 2, 3, 0, 1, 2, 3, \dots, 0, 1, 2, 3$。洗牌的過程一共有三個步驟：</p><ol><li>進行切牌，切牌的位置與次數並不重要。</li><li>隨機取 $X = 1 \sim 40$，並將前 $X$ 張牌的順序反過來分成一堆，剩下的 $40 - X$ 分成另外一堆。</li><li>將這兩堆牌進行交疊洗牌 (不是完美的交疊洗牌也沒關係)。</li></ol><p>這樣洗牌的結果會是每 $4$ 張牌都會包含 $0 \sim 3$ 各一張。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>聽起來非常的神奇，為什麼會有這個現象呢？我們對洗牌的過程進行分析。</p><p>首先，切牌後牌的順序會變成以下四種情況之一：</p><p>a. $0, 1, 2, 3, \dots, 0, 1, 2, 3$<br>b. $3, 0, 1, 2, \dots, 3, 0, 1, 2$<br>c. $2, 3, 0, 1, \dots, 2, 3, 0, 1$<br>d. $1, 2, 3, 0, \dots, 1, 2, 3, 0$</p><p>這四種情況都維持「每 $4$ 張牌都會包含 $0 \sim 3$ 各一張」的這個性質。因此不失一般性我們可以假設切牌次數為 $0$。</p><p>步驟 $2$ 和 $3$ 我們一起看。將 $X$ 張牌順序反過來放一堆，因此這 $X$ 張牌的頭是原本的尾，並與另外一堆進行交疊洗牌。因為交疊洗牌每次都是取兩堆的頭，而其中一堆的頭是原牌序的尾，因此等價於「在初始排序中，每次從牌頭或牌尾取一張牌並按照取走的順序排好，直到取完」。又因為初始的排序其實可以看成是一個循環 (以 a. 來說最後面的 $3$ 接到最前面的 $0$)，因此在原牌序中不論是取頭或取尾，取走的牌都會對應到循環中一段連續的區間。因此不管怎麼取，連續的 $4$ 張牌都一定會包含 $0 \sim 3$ 各一張。</p><p>綜上所述，吉爾布雷斯洗牌法能夠成立的先決條件是牌的初始順序。在動漫中，每次發牌都是使用新的一副牌，因此初始順序是固定的。</p><h2 id="應用"><a href="#應用" class="headerlink" title="應用"></a>應用</h2><p>有兩間工廠 A 和 B 生產同一件產品，而生產又分為四個步驟。某天兩間工廠打算合作，A 工廠按照 $1, 2, 3, 4$ 的順序進行，B 工廠反過來按照 $4, 3, 2, 1$ 的順序進行。按照上述的原理每四個步驟必定包含 $1 \sim 4$ 各一個，符合經濟效益。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://forum.gamer.com.tw/C.php?bsn=43189&amp;snA=192">【閒聊】談第二季第四集中出現的 Gilbreath’s principle</a></li><li><a href="https://www.scimonth.com.tw/archives/5791">【科學月刊】有趣的撲克牌小魔術 - 吉爾布雷斯法則之應用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 雜項 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 動漫 </tag>
            
            <tag> 吉爾布雷斯洗牌法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【筆記】擴展歐幾里得算法 (Extended Euclidean Algorithm)</title>
      <link href="/posts/extended-euclidean-algorithm/"/>
      <url>/posts/extended-euclidean-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>對於整數 $a$ 和 $b$，求出 $x$ 和 $y$ 滿足 $ax + by = \gcd(a,b)$</p><h2 id="演算法"><a href="#演算法" class="headerlink" title="演算法"></a>演算法</h2><p>令 $g = \gcd(a, b)$，我們可以透過遞迴求出 $(x, y)$。更具體一點，我們可以在做輾轉相除法的過程中順便求出 $(x, y)$。</p><p>先來看輾轉相除法的 base case。當 $a = g$ 且 $b = 0$ 時，不難看出 $a \cdot 1 + b \cdot 0 = g$ 滿足條件。此時 $(x, y) = (1, 0)$。</p><p>現在問題變成如何透過 $\gcd(b, a \bmod b)$ 的係數 $(x^{\prime}, y^{\prime})$ 求出 $\gcd(a, b)$ 的係數 $(x, y)$？</p><p>根據定義，我們可以列出</p><p>$$b x^{\prime} + (a \bmod b) y^{\prime} = g$$</p><p>由於 $a \bmod b = a - \lfloor \frac{a}{b} \rfloor \cdot b$，替換後得到</p><p>$$b x^{\prime} + (a - \lfloor \frac{a}{b} \rfloor \cdot b) y^{\prime} = g$$</p><p>整理係數，將 $a$ 和 $b$ 提出來後得到</p><p>$$a y^{\prime} + b (x^{\prime} - \lfloor \frac{a}{b} \rfloor \cdot y^{\prime}) = g$$</p><p>比對係數，此時 $ax + by = g$ 的解為</p><p>\begin{cases}<br>x = y^{\prime} \\<br>y = x^{\prime} - \lfloor \frac{a}{b} \rfloor \cdot y^{\prime}<br>\end{cases}</p><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ext_gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>{<br><span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) {<br>x = <span class="hljs-number">1</span>;<br>y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> a;<br>}<br><span class="hljs-type">int</span> x1, y1;<br><span class="hljs-type">int</span> g = <span class="hljs-built_in">ext_gcd</span>(b, a % b, x1, y1);<br>x = y1;<br>y = x1 - (a / b) * y1;<br><span class="hljs-keyword">return</span> g;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="應用"><a href="#應用" class="headerlink" title="應用"></a>應用</h2><h3 id="求模反元素-Modular-Inverse"><a href="#求模反元素-Modular-Inverse" class="headerlink" title="求模反元素 (Modular Inverse)"></a>求模反元素 (Modular Inverse)</h3><p>我們要求 $a$ 在模 $m$ ($a$ 和 $m$ 互質) 情況下的逆元 $a^{-1}$ 使得 $a \cdot a^{-1} \equiv 1 \pmod m$。列出</p><p>$$ax + my = \gcd(a, m) = 1$$</p><p>因為 $my$ 是 $m$ 的倍數，因此 $ax + my \equiv ax \equiv 1 \pmod m$，$x$ 就是 $a$ 在模 $m$ 下的模逆元 $a^{-1}$！</p><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ul><li><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1045">UVA 10104 - Euclid Problem</a></li><li><a href="https://zerojudge.tw/ShowProblem?problemid=a289">Zerojudge a289: Modular Multiplicative Inverse</a></li><li><a href="https://atcoder.jp/contests/abc315/tasks/abc315_g">ABC315 G - Ai + Bj + Ck = X (1 &lt;= i, j, k &lt;= N)</a></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://cp-algorithms.com/algebra/extended-euclid-algorithm.html">CP-Algorithms - Extended Euclidean Algorithm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 數論 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【題解】ABC313 D - Odd or Even</title>
      <link href="/posts/abc313d/"/>
      <url>/posts/abc313d/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc313/tasks/abc313_d">題目連結</a></p><h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><p>有一個隱藏的長度為 $N$ 的數列，每一項為 $0$ 或 $1$，你要猜出數列每一項的數值。你可以問至多 $N$ 個問題。給定常數 $K$，每次詢問 $K$ 個 index，judge 會告訴你這些 index 加起來的奇偶性。judge 是 adaptive 的，也就是他的答案不固定，只要不與 judge 的回答自相矛盾的都有可能是答案。</p><ul><li>$1 \leq K &lt; N \leq 1000$</li><li>$K$ 是奇數</li></ul><h2 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h2><p>我們可以透過兩個詢問來得知兩個位置的數值是否相同。假設第一次我們呼叫 $query(a_1, \dots, a_k) = x$，第二次呼叫 $query(a_1, \dots, a_{k - 1}, a_{k + 1}) = y$，如果 $x = y$，則我們知道 $a_k = a_{k + 1}$，否則 $a_k \neq a_{k + 1}$。透過 $N$ 次的詢問我們可以將所有 index 分成兩組，其中一組的數值全部都是 $0$，另外一組全部都是 $1$。最後因為 $K$ 是奇數，也可以判斷出兩組各自的數值。實作細節請參考 code。</p><p><a href="https://atcoder.jp/contests/abc313/submissions/44278230">Solution Code</a></p>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互動題 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【題解】ABC311 F - Yet Another Grid Task</title>
      <link href="/posts/abc311f/"/>
      <url>/posts/abc311f/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc311/tasks/abc311_f">題目連結</a></p><h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><p>給定 $N \times M$ 個格子，每個格子為黑或白。如果 $(i, j)$ 為黑，則下方 $(i + 1, j)$ 和右下方 $(i + 1, j + 1)$ 也會被染成黑色。一開始已經有一些格子是黑色，現在你可以將某些白色的格子塗成黑色，問最後可以產生幾種相異的版面 $\bmod{998244353}$。</p><ul><li>$1 \leq N, M \leq 2000$</li></ul><h2 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h2><p>官方的<a href="https://atcoder.jp/contests/abc311/editorial/6828">題解</a>寫了個不直觀的斜線 $dp$，因此這邊提供一個比較簡單的作法。</p><p>因為黑色會向下染色，因此每一列都會是上面白色下面黑色。根據這個觀察，我們可以定義 $dp[i][j]$ 為只考慮前 $i$ 列且 $(i, j)$ 為第 $i$ 列最上方的黑色格子，或是 $dp[i][n]$ 為該列沒有黑色格子。因為黑色會往右下方染色，在 $(i - 1, j - 1)$ 上方的格子都不能是黑色，否則 $(i, j)$ 就不會是該列最上方黑色的格子。因此我們可以列出 $dp$ 的轉移式：</p><p>$$dp[i][j] = \sum\limits_{k = \max(0, j - 1)}^n dp[i - 1][k]$$</p><p>這個轉移可以透過預處理後用後綴和 $O(1)$ 得到。時間複雜度為 $O(NM)$。</p><p><a href="https://atcoder.jp/contests/abc311/submissions/44246658">Solution Code</a></p>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【題解】ABC312 G - Avoid Straight Line</title>
      <link href="/posts/abc312g/"/>
      <url>/posts/abc312g/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc312/tasks/abc312_g">題目連結</a></p><h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><p>給定一棵 $N$ 個節點的樹，問有幾組 $(i, j, k)$ 滿足 $i &lt; j &lt; k$ 且在樹上三個節點不會形成一條路徑？</p><ul><li>$1 \leq N \leq 2 \cdot 10^5$</li></ul><h2 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h2><p>三點不形成一條路徑的方法數可能不太直覺，我們改成用扣除的，也就是計算 $(\text{全部} - \text{三點形成一條路徑})$ 的方法數。全部就是 $\binom{N}{3}$，因此問題化簡為計算三點形成一條路徑的方法數。</p><p>我們枚舉三點中的中點 $u$，其他兩個點必定落在 $u$ 的兩個不同子樹。假設 $u$ 有 $k$ 個子樹，子樹的大小分別為 $sz_1, \dots, sz_k$，則 $u$ 為中點的方法數為：</p><p>$$\sum\limits_{i = 1}^{k - 1} \sum\limits_{j = i + 1}^k sz_i sz_j = \sum\limits_{i = 1}^{k - 1} sz_i (\sum\limits_{j = i + 1}^k sz_j)$$</p><p>可以在 $O(k)$ 求得。</p><p>因為每個節點都可能成為三點中的中點，每個節點都要把他當成樹根，因此我們需要用到換根的技巧，可以在 $O(1)$ 重新計算當樹根從相鄰節點 $u$ 移動到 $v$ 時子樹大小的改變，詳細作法請參考程式碼。</p><p><a href="https://atcoder.jp/contests/abc312/submissions/44238184">Solution Code</a></p>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【筆記】IO 優化</title>
      <link href="/posts/fast-io/"/>
      <url>/posts/fast-io/</url>
      
        <content type="html"><![CDATA[<p>本文將會介紹一些 IO 優化的方法。</p><h2 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h2><p>使用 <code>iostream</code> 下的 <code>cin/cout</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">int</span> a;<br>std::cin &gt;&gt; a;<br>std::cout &lt;&lt; a &lt;&lt; std::endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>以上的程式碼在輸入輸出量巨大的時候很有可能會吃 TLE。實際上 <code>cin/cout</code> 會慢是因為 compiler 為了要讓 <code>cin/cout</code> 和 <code>scanf/printf</code> 可以混著用，因此多處理了一些東西，導致速度變慢。把同步的功能關掉後，<code>cin/cout</code> 的速度就會快非常多，基本上在各大 OJ 就很夠用了。需要注意的是把同步關閉後就不能夠在使用 <code>scanf/printf</code> 了。除此之外，把 <code>std::endl</code> 換成 <code>"\n"</code> 也會快很多，因為 <code>std::endl</code> 每次會把緩衝區清空。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> a;<br>std::cin &gt;&gt; a;<br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">"\n"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="getchar-x2F-putchar"><a href="#getchar-x2F-putchar" class="headerlink" title="getchar/putchar"></a>getchar/putchar</h2><p><code>getchar</code> 和 <code>putchar</code> 是內建的函式，在 <code>stdio.h</code> 下。<code>getchar</code> 一次讀入一個字元，<code>putchar</code> 一次輸出一個字元。透過這兩個函式，我們可以自己手刻輸入和輸出。</p><p>接下來進入黑科技了。</p><h2 id="getchar-unlocked-x2F-putchar-unlocked"><a href="#getchar-unlocked-x2F-putchar-unlocked" class="headerlink" title="getchar_unlocked/putchar_unlocked"></a>getchar_unlocked/putchar_unlocked</h2><p>使用方法與 <code>getchar/putchar</code> 相同，但加上 <code>unlocked</code> 後速度更快。這兩個函式並不是在所有環境都能夠執行，在 Windows 下要改成 <code>_getchar_nolock</code> 和 <code>_putchar_nolock</code>。</p><h2 id="fread-x2F-fwrite"><a href="#fread-x2F-fwrite" class="headerlink" title="fread/fwrite"></a>fread/fwrite</h2><p>使用時一樣要引入 <code>stdio.h</code>。<code>fread</code> 會一次讀取多個字元。一般而言我們會先透過 <code>fread</code> 讀取字元後存進一個字元陣列，模擬 <code>getchar</code> 的作用。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">gc</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF_SIZE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> buffer[BUF_SIZE];<br><span class="hljs-type">static</span> <span class="hljs-type">char</span>* s = buffer + BUF_SIZE;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span>* e = buffer + BUF_SIZE;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = BUF_SIZE;<br><span class="hljs-keyword">if</span>(s == e) {<br><span class="hljs-keyword">if</span>(cnt &lt; BUF_SIZE) {<br><span class="hljs-keyword">return</span> EOF;<br>}<br>cnt = <span class="hljs-built_in">fread</span>(buffer, <span class="hljs-number">1</span>, BUF_SIZE, stdin);<br>s = buffer, e = buffer + cnt;<br>}<br><span class="hljs-keyword">return</span> *s++;<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>fwrite</code> 也是類似，先把要輸出的東西存在陣列，在直接使用 <code>fwrite</code> 一次將全部印出來。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF_SIZE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>;<br><span class="hljs-type">char</span> buffer[BUF_SIZE];<br><span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pc</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>{<br>buffer[p++] = c;<br><span class="hljs-keyword">if</span>(p == BUF_SIZE) {<br><span class="hljs-built_in">output</span>();<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">fwrite</span>(buffer, <span class="hljs-number">1</span>, p, stdout);<br>p = <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>上述的程式碼只有在 <code>buffer</code> 滿的時候才會透過 <code>fwrite</code> 輸出，因此在程式結束之前我們要手動呼叫 <code>output</code> 讓他把剩下的也都輸出。</p><p><code>fread/fwrite</code> 也有 <code>unlocked</code> 系列的 <code>fread_unlocked/fwrite_unlocked</code>，但是速度差異不大。</p><p>特別注意有些 OJ 不支援 <code>fwrite</code> (像是 Zerojudge)，因此可以用 <code>fwrite + putchar_unlocked</code> 的組合。</p><h2 id="tourist-IO"><a href="#tourist-IO" class="headerlink" title="tourist IO"></a>tourist IO</h2><p>這是筆者在 tourist 的 <a href="https://codeforces.com/contest/1603/submission/133678384">submission</a> 翻到的，並進行了微調。預設使用了 <code>fread/fwrite</code> 的組合。如果 OJ 不支援 <code>fread</code> 或是 <code>fwrite</code>，可以在 <code>get_char</code> 和 <code>put_char</code> 函式裡面去修改成 <code>getchar_unlocked/putchar_unlocked</code>。這個模板的好處是有 <code>#define cin fast_input</code> 和 <code>#define cout fast_output</code>，因此使用 <code>cin/cout</code> 的人可以直接把這段程式碼貼到最上方，不用對 <code>main</code> 去做修改 (甚至連關閉同步的那兩行都不用拿掉)，甚至支援 <code>__int128</code> 和讀到 EOF！另外筆者把整個包在 <code>namespace std</code> 下，並加上了 <code>#define istream FastInput</code> 和 <code>#define ostream FastOutput</code>，因此可以客製化 <code>struct</code> 的輸入輸出。</p><details><summary>tourist IO Code</summary><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// https://codeforces.com/contest/1603/submission/133678384</span><br><span class="hljs-keyword">namespace</span> std {<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastInput</span> {<br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> BUF_SIZE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>;<br><span class="hljs-type">char</span> buf[BUF_SIZE];<br><span class="hljs-type">size_t</span> chars_read = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> buf_pos = <span class="hljs-number">0</span>;<br>FILE *in = stdin;<br><span class="hljs-type">char</span> cur = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get_char</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">if</span>(buf_pos &gt;= chars_read) {<br>chars_read = <span class="hljs-built_in">fread</span>(buf, <span class="hljs-number">1</span>, BUF_SIZE, in);<br>buf_pos = <span class="hljs-number">0</span>;<br>buf[<span class="hljs-number">0</span>] = (chars_read == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : buf[<span class="hljs-number">0</span>]);<br>}<br><span class="hljs-keyword">return</span> cur = buf[buf_pos++];<br><span class="hljs-comment">// return cur = getchar_unlocked();</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">tie</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>{}<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> cur != <span class="hljs-number">-1</span>; }<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">is_blank</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>{ <span class="hljs-keyword">return</span> c &lt;= <span class="hljs-string">' '</span>; }<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">skip_blanks</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">is_blank</span>(cur) &amp;&amp; cur != <span class="hljs-number">-1</span>) {<br><span class="hljs-built_in">get_char</span>();<br>}<br><span class="hljs-keyword">return</span> cur != <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-keyword">inline</span> FastInput&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(<span class="hljs-type">char</span>&amp; c) {<br><span class="hljs-built_in">skip_blanks</span>();<br>c = cur;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br><br><span class="hljs-keyword">inline</span> FastInput&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(string&amp; s) {<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">skip_blanks</span>()) {<br>s.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">do</span> {<br>s += cur;<br>} <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_blank</span>(<span class="hljs-built_in">get_char</span>()));<br>}<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> FastInput&amp; <span class="hljs-title">read_integer</span><span class="hljs-params">(T&amp; n)</span> </span>{<br>n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">skip_blanks</span>()) {<br><span class="hljs-type">int</span> sign = +<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(cur == <span class="hljs-string">'-'</span>) {<br>sign = <span class="hljs-number">-1</span>;<br><span class="hljs-built_in">get_char</span>();<br>}<br><span class="hljs-keyword">do</span> {<br>n += n + (n &lt;&lt; <span class="hljs-number">3</span>) + cur - <span class="hljs-string">'0'</span>;<br>} <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_blank</span>(<span class="hljs-built_in">get_char</span>()));<br>n *= sign;<br>}<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> enable_if&lt;is_integral&lt;T&gt;::value, FastInput&amp;&gt;::type <span class="hljs-keyword">operator</span>&gt;&gt;(T&amp; n) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">read_integer</span>(n); }<br><span class="hljs-keyword">inline</span> FastInput&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(__int128&amp; n) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">read_integer</span>(n); }<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> enable_if&lt;is_floating_point&lt;T&gt;::value, FastInput&amp;&gt;::type <span class="hljs-keyword">operator</span>&gt;&gt;(T&amp; n) {<br>n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">skip_blanks</span>()) {<br>string s;<br>(*<span class="hljs-keyword">this</span>) &gt;&gt; s;<br><span class="hljs-built_in">sscanf</span>(s.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">"%lf"</span>, &amp;n);<br>}<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br>} fast_input;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> istream FastInput</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cin fast_input</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">FastOutput</span> {<br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> BUF_SIZE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>;<br><span class="hljs-type">char</span> buf[BUF_SIZE];<br><span class="hljs-type">size_t</span> buf_pos = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> TMP_SIZE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>;<br><span class="hljs-type">char</span> tmp[TMP_SIZE];<br>FILE *out = stdout;<br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">put_char</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>{<br>buf[buf_pos++] = c;<br><span class="hljs-keyword">if</span>(buf_pos == BUF_SIZE) {<br><span class="hljs-built_in">fwrite</span>(buf, <span class="hljs-number">1</span>, buf_pos, out);<br>buf_pos = <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">// putchar_unlocked(c);</span><br>}<br><br>~<span class="hljs-built_in">FastOutput</span>() {<br><span class="hljs-built_in">fwrite</span>(buf, <span class="hljs-number">1</span>, buf_pos, out);<br>}<br><br><span class="hljs-keyword">inline</span> FastOutput&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">char</span> c) {<br><span class="hljs-built_in">put_char</span>(c);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br><br><span class="hljs-keyword">inline</span> FastOutput&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s) {<br><span class="hljs-keyword">while</span>(*s) {<br><span class="hljs-built_in">put_char</span>(*s++);<br>}<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br><br><span class="hljs-keyword">inline</span> FastOutput&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> string&amp; s) {<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>) s.<span class="hljs-built_in">size</span>(); i++) {<br><span class="hljs-built_in">put_char</span>(s[i]);<br>}<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span>* <span class="hljs-title">integer_to_string</span><span class="hljs-params">(T n)</span> </span>{<br><span class="hljs-type">char</span>* p = tmp + TMP_SIZE - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) {<br>*--p = <span class="hljs-string">'0'</span>;<br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-type">bool</span> is_negative = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>) {<br>is_negative = <span class="hljs-literal">true</span>;<br>n = -n;<br>}<br><span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) {<br>*--p = (<span class="hljs-type">char</span>) (<span class="hljs-string">'0'</span> + n % <span class="hljs-number">10</span>);<br>n /= <span class="hljs-number">10</span>;<br>}<br><span class="hljs-keyword">if</span>(is_negative) {<br>*--p = <span class="hljs-string">'-'</span>;<br>}<br>}<br><span class="hljs-keyword">return</span> p;<br>}<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> enable_if&lt;is_integral&lt;T&gt;::value, <span class="hljs-type">char</span>*&gt;::<span class="hljs-function">type <span class="hljs-title">stringify</span><span class="hljs-params">(T n)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">integer_to_string</span>(n); }<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span>* <span class="hljs-title">stringify</span><span class="hljs-params">(__int128 n)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">integer_to_string</span>(n); }<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> enable_if&lt;is_floating_point&lt;T&gt;::value, <span class="hljs-type">char</span>*&gt;::<span class="hljs-function">type <span class="hljs-title">stringify</span><span class="hljs-params">(T n)</span> </span>{<br><span class="hljs-built_in">sprintf</span>(tmp, <span class="hljs-string">"%.17f"</span>, n);<br><span class="hljs-keyword">return</span> tmp;<br>}<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">inline</span> FastOutput&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-type">const</span> T&amp; n) {<br><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">stringify</span>(n);<br><span class="hljs-keyword">for</span>(; *p != <span class="hljs-number">0</span>; p++) {<br><span class="hljs-built_in">put_char</span>(*p);<br>}<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br>} fast_output;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ostream FastOutput</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cout fast_output</span><br><br>} <span class="hljs-comment">// namespace std</span><br></code></pre></td></tr></tbody></table></figure></details><p>tourist IO 也可以客製化 <code>struct</code> 的輸入輸出，與常見的寫法相同。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; in, std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p) {<br><span class="hljs-keyword">return</span> in &gt;&gt; p.first &gt;&gt; p.second;<br>}<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out, std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p) {<br><span class="hljs-keyword">return</span> out &lt;&lt; p.first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; p.second;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://codeforces.com/contest/1603/submission/133678384">tourist IO</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO 優化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【筆記】Link Cut Tree</title>
      <link href="/posts/link-cut-tree/"/>
      <url>/posts/link-cut-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>Link Cut Tree 是一種資料結構，能夠動態維護樹/森林的聯通性和一些路徑上的操作和查詢。</p><blockquote><p>請你維護一些森林，並進行以下操作 (強制在線)：</p><ol><li>修改 $u, v$ 路徑上的權值</li><li>查詢 $u, v$ 路徑上的權值和</li><li>在 $u, v$ 之間連邊 (保證連邊之前 $u, v$ 不連通)</li><li>斷開 $u, v$ 之間的邊</li></ol></blockquote><p>單看 1 和 2 的話就是輕重鏈剖分的模板題。現在加上了連邊和斷邊的操作，這部分是輕重鍊剖分無法快速維護的。話雖如此，我們可以沿用它的精神，重新定義樹鏈，並用不同的方式維護。</p><h2 id="鏈的維護"><a href="#鏈的維護" class="headerlink" title="鏈的維護"></a>鏈的維護</h2><p>在 Link Cut Tree 中，每一條邊的狀態是根據最後一次的操作決定的。假設最後一次操作節點 $v$，則我們會把 $root$ 到 $v$ 的路徑設為重鏈。因此，每個節點 $v$ 最多只有一條連向自己兒子的重邊。我們稱這條邊為 $v$ 的 preferred edge，連到的子孫為 $v$ 的 preferred child。每一條鏈我們都用一棵 Splay Tree 維護，具體的維護方式會在等下提到。</p><p>我們先來定義一些名詞：</p><ul><li>代表樹：原本的樹。</li><li>輔助樹：維護鏈的 Splay Tree。</li><li>path parent：重鏈在代表樹中深度最小節點的父節點。</li><li>parent：節點在輔助樹中的父節點。</li></ul><p>每棵輔助樹內部會按照節點在代表樹的深度 ($v$ 的深度為代表樹 $root$ 到 $v$ 的距離) 作為權值維護 Splay Tree。</p><p><img src="/posts/link-cut-tree/lct-01.png" alt="Link Cut Tree 範例"></p><p>左圖中紅色的邊為重邊，藍色的數字為節點的深度。</p><p>右圖中由黑色的邊連起來的節點為一棵輔助樹。每一棵輔助樹滿足二元搜尋樹的性質。輔助樹之間被橘色的邊連起來，由輔助樹的 $root$ 連向 path parent。以 $EF$ 這條鏈來說，$E$ 是代表樹中深度最淺的點，path parent 為 $D$。因此 $EF$ 輔助樹的 $root$ $F$ 連向 $D$。</p><p>Splay Tree 中核心的操作為 <code>splay()</code>，把節點透過左旋和右旋移動到根結點，並保持二元搜尋樹的性質。<code>splay()</code> 操作的時間複雜度均攤為 $O(\log n)$。當我們在對 Splay Tree 旋轉的時候連向 path parent 的邊也要一起維護。</p><p>以下的程式碼為 Splay Tree 一些關鍵的函式。<code>rev</code> 變數為反轉的懶人標記。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">splay_node</span> {<br>splay_node* l = <span class="hljs-literal">nullptr</span>;<br>splay_node* r = <span class="hljs-literal">nullptr</span>;<br>splay_node* p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">bool</span> rev = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_root</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> p == <span class="hljs-literal">nullptr</span> || (p-&gt;l != <span class="hljs-keyword">this</span> &amp;&amp; p-&gt;r != <span class="hljs-keyword">this</span>); }<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">if</span>(rev) {<br>std::<span class="hljs-built_in">swap</span>(l, r);<br><span class="hljs-keyword">if</span>(l != <span class="hljs-literal">nullptr</span>) {<br>l-&gt;rev ^= <span class="hljs-number">1</span>;<br>}<br><span class="hljs-keyword">if</span>(r != <span class="hljs-literal">nullptr</span>) {<br>r-&gt;rev ^= <span class="hljs-number">1</span>;<br>}<br>rev = <span class="hljs-literal">false</span>;<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">auto</span> g = p-&gt;p;<br><span class="hljs-keyword">if</span>(!p-&gt;<span class="hljs-built_in">is_root</span>()) {<br>(g-&gt;r == p ? g-&gt;r : g-&gt;l) = <span class="hljs-keyword">this</span>;<br>}<br>p-&gt;<span class="hljs-built_in">push</span>();<br><span class="hljs-built_in">push</span>();<br><span class="hljs-keyword">if</span>(p-&gt;l == <span class="hljs-keyword">this</span>) {<br>p-&gt;l = r;<br>r = p;<br><span class="hljs-keyword">if</span>(p-&gt;l != <span class="hljs-literal">nullptr</span>) {<br>p-&gt;l-&gt;p = p;<br>}<br>} <span class="hljs-keyword">else</span> {<br>p-&gt;r = l;<br>l = p;<br><span class="hljs-keyword">if</span>(p-&gt;r != <span class="hljs-literal">nullptr</span>) {<br>p-&gt;r-&gt;p = p;<br>}<br>}<br>p-&gt;p = <span class="hljs-keyword">this</span>;<br>p = g;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">is_root</span>()) {<br><span class="hljs-keyword">auto</span> g = p-&gt;p;<br><span class="hljs-keyword">if</span>(!p-&gt;<span class="hljs-built_in">is_root</span>()) {<br>((g-&gt;r == p) == (p-&gt;r == <span class="hljs-keyword">this</span>) ? p : <span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">rotate</span>();<br>}<br><span class="hljs-built_in">rotate</span>();<br>}<br><span class="hljs-built_in">push</span>();<br>}<br>};<br></code></pre></td></tr></tbody></table></figure><p>因為一棵輔助樹只有根結點需要存這條鏈的 path parent，程式碼中的變數 <code>p</code> 與 path parent 共用。<code>is_root()</code> 函式的實作方式也稍有不同，如果 <code>p</code> 沒有指向自己的話代表這個 <code>p</code> 是 path parent (右圖中橘色的邊)，否則是 Splay Tree 中的 parent (右圖中黑色的邊)。因此輔助樹的 $root$ 的 <code>p</code> 會有找不到自己兒子的情況。</p><h2 id="Link-Cut-Tree-函式"><a href="#Link-Cut-Tree-函式" class="headerlink" title="Link Cut Tree 函式"></a>Link Cut Tree 函式</h2><p><code>access(v)</code>：把 $v$ 到根結點的路徑設為重鏈。</p><p><img src="/posts/link-cut-tree/lct-02.png" alt="Access 函式示意圖"></p><p>注意到 $C$ 和 $H$ 之間的重邊不會被斷開。</p><p>先對 $F$ 呼叫 <code>splay()</code> 旋轉到 $EF$ 輔助樹的樹根。因為 $F$ 是最後操作的節點，根據定義他沒有 preferred child，所以要把 $F$ 在輔助樹的右兒子斷開 (因為輔助樹按照節點在代表樹的深度維護，$F$ 在輔助樹中右子樹節點在代表樹中的深度都比 $F$ 深)。</p><p>此時 $F$ 變成輔助樹的樹根，他的 path parent 是 $D$。我們要把 $D$ 的 preferred child 變成 $E$，相當於在輔助樹中將 $D$ 的右兒子設成 $E$ 所在的輔助樹的根結點 $F$。先把 $D$ <code>splay()</code> 到 $DG$ 輔助樹的樹根，然後把右兒子斷開並連到 $F$。這樣我們就成功合併兩棵輔助樹，相當於合併成一條重鏈，並且輔助樹維持二元搜尋樹的性質。</p><p>我們持續往上合併，直到重鏈連接到樹根。最後 $A$ 到 $F$ 形成一條重鏈，也就是他們在同一棵輔助樹中。最後我們再對 F 呼叫 <code>splay()</code>，讓 F 旋轉到輔助樹的樹根，此時 $F$ 沒有 parent。</p><p><img src="/posts/link-cut-tree/lct-03.gif" alt="Access 函式動畫"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">splay_node* <span class="hljs-title">access</span><span class="hljs-params">(splay_node* v)</span> </span>{<br>splay_node* last = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">for</span>(splay_node* p = v; p != <span class="hljs-literal">nullptr</span>; p = p-&gt;p) {<br>p-&gt;<span class="hljs-built_in">splay</span>();<br>p-&gt;r = last;<br>last = p;<br>}<br>v-&gt;<span class="hljs-built_in">splay</span>();<br><span class="hljs-keyword">return</span> last;<br>}<br></code></pre></td></tr></tbody></table></figure><p>有了 <code>access(v)</code> 的核心操作之後，剩下的操作就簡單很多了。</p><p><code>make_root(v)</code>：把 $v$ 設定為代表樹中的樹根。</p><p>我們先呼叫 <code>access(v)</code>，讓根結點到 $v$ 成為一條鏈，此時 $v$ 是這條鏈中最深的節點，並且位於輔助樹的樹根。我們對 $v$ 打反轉的懶人標記，這樣 $v$ 就變成這條鏈中深度最淺的節點，也就變成樹根了！</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">make_root</span><span class="hljs-params">(splay_node* v)</span> </span>{<br><span class="hljs-built_in">access</span>(v);<br>v-&gt;rev ^= <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>link(u, v)</code>：在 $u, v$ 之間連一條邊。</p><p>先呼叫 <code>make_root(v)</code>，讓 $v$ 變成他代表樹的根結點，接著直接把他的 path parent 設為 $u$。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(splay_node* u, splay_node* v)</span> </span>{<br><span class="hljs-built_in">make_root</span>(v);<br>v-&gt;p = u;<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>cut(u, v)</code>：切斷連接 $u, v$ 的邊。</p><p>先呼叫 <code>make_root(u)</code>，讓 $u$ 變成代表樹的樹根。接著再呼叫 <code>access(v)</code>，讓 $u, v$ 形成一條長度為 $1$ 的重鏈，且因為 $v$ 是最後 <code>access</code> 的點，所以他位於輔助樹的樹根，左邊的兒子是 $u$。最後直接移除 $v$ 的左兒子，和把 $u$ 的 parent 設為 <code>null</code> ($u$ 的 parent 也要移除，否則只是讓 $v$ 變成 $u$ 的 path parent)。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(splay_node* u, splay_node* v)</span> </span>{<br><span class="hljs-built_in">make_root</span>(u);<br><span class="hljs-built_in">access</span>(v);<br>v-&gt;l-&gt;p = <span class="hljs-literal">nullptr</span>;<br>v-&gt;l = <span class="hljs-literal">nullptr</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>is_connected(u, v)</code>：回傳 $u, v$ 是否連通。</p><p>先呼叫 <code>access(u)</code>，讓根結點到 $u$ 成為一條鏈，且 $u$ 為這條鏈輔助樹的樹根，因此 $u$ 沒有 parent。這時候再呼叫 <code>access(v)</code>，這時候 $v$ 也沒有 parent。因為一棵代表樹中只有根結點所在的輔助樹樹根會沒有 parent。如果 $u$ 在 <code>access(v)</code> 後變成有 parent，就代表 $u, v$ 在同一棵代表樹上，也就是連通。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_connected</span><span class="hljs-params">(splay_node* u, splay_node* v)</span> </span>{<br><span class="hljs-built_in">access</span>(u);<br><span class="hljs-built_in">access</span>(v);<br><span class="hljs-keyword">return</span> u-&gt;p != <span class="hljs-literal">nullptr</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="優化-Dinic"><a href="#優化-Dinic" class="headerlink" title="優化 Dinic"></a>優化 Dinic</h2><p>我們可以使用 Link Cut Tree 來優化 Dinic，達到 $O(VE \log V)$ 的時間複雜度。有 $4$ 種操作可以用 Link Cut Tree 進行優化：</p><ol><li>加邊：增廣時加邊直到 source 跟 sink 連通。</li><li>求路徑最小值：尋找增廣路徑中剩餘流量最小的邊。</li><li>路徑修改：把增廣路上的 capacity 全部減少增廣的流量</li><li>刪邊：刪掉 capacity 為 $0$ 的邊</li></ol><p>以上 $4$ 種操作都能夠以 Link Cut Tree 維護。</p><p>雖然用 Link Cut Tree 的理論時間複雜度較優，但實際上因為常數頗大，除非範圍很大，否則執行時間不會比較快。</p><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ul><li><a href="https://zerojudge.tw/ShowProblem?problemid=b483">Zerojudge b483. 史蒂芙的觀察日記</a></li><li><a href="https://zerojudge.tw/ShowProblem?problemid=b486">Zerojudge b486. 變態史考古</a></li><li><a href="https://zerojudge.tw/ShowProblem?problemid=b487">Zerojudge b487. 變態史考古 錯誤報導篇</a></li><li><a href="https://zerojudge.tw/ShowProblem?problemid=e003">Zerojudge e003. 樹形避難所 I</a></li><li><a href="https://zerojudge.tw/ShowProblem?problemid=e004">Zerojudge e004. 樹形避難所 II</a></li><li><a href="https://judge.yosupo.jp/problem/dynamic_tree_vertex_set_path_composite">Library Checker - Dynamic Tree Vertex Set Path Composite</a></li><li><a href="https://www.spoj.com/problems/DYNACON1/">SPOJ - DYNACON1 - Dynamic Tree Connectivity</a></li><li><a href="https://codeforces.com/contest/117/problem/E">CF 117E - Tree or not Tree</a></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://sunmoon-template.blogspot.com/2015/11/link-cut-tree.html">日月卦長的模板庫 - [ link-cut tree ] 動態樹教學+模板</a></li><li><a href="https://oi-wiki.org/ds/lct/">OI Wiki - Link Cut Tree</a></li><li><a href="https://usaco.guide/adv/link-cut-tree?lang=cpp">USACO - Link Cut Tree</a></li><li><a href="https://codeforces.com/blog/entry/80383">CF - Link-cut tree tutorial</a></li><li><a href="https://zhuanlan.zhihu.com/p/51592593">Link Cut Tree 優化 Dinic</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Link Cut Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【筆記】Slope Trick</title>
      <link href="/posts/slope-trick/"/>
      <url>/posts/slope-trick/</url>
      
        <content type="html"><![CDATA[<h2 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h2><p>Slope Trick 是一種表示某種特定函數的方式，該函數滿足：</p><ol><li>函數在座標平面上連續</li><li>可以被分成多個區段，每個區段都是線性函數</li><li>每個區段的斜率由左到右遞增或遞減，也就是凹或凸函數</li></ol><p>我們稱它為 <strong>分段線性凸(凹)函數 (Slope Trickable Function)</strong>。</p><p>這個技巧可以被用來優化 DP。</p><h2 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h2><p>我們稱函數斜率改變的地方為分段點。紀錄分段點的 $x$ 座標，每次代表函數的斜率 $+1$。</p><table><thead><tr><th align="center"><img src="/posts/slope-trick/slope-trickable-function-1.png" alt="Slope Trickable Function 範例 1"></th><th align="center"><img src="/posts/slope-trick/slope-trickable-function-2.png" alt="Slope Trickable Function 範例 2"></th></tr></thead><tbody><tr><td align="center">分段點 = $[0]$</td><td align="center">分段點 = $[-3, 2, 10, 10]$</td></tr></tbody></table><h2 id="性質"><a href="#性質" class="headerlink" title="性質"></a>性質</h2><p>若兩個函數 $f(x), g(x)$ 為 Slope Trickable Function，且同時為凹(或凸)函數，則 $h(x) = f(x) + g(x)$ 也會是 Slope Trickable Function。同時，$h(x)$ 的分段點會是 $f(x)$ 和 $g(x)$ 分段點的聯集。</p><h2 id="例題"><a href="#例題" class="headerlink" title="例題"></a>例題</h2><blockquote><p><a href="https://cses.fi/problemset/task/2132">CSES - Increasing Array II</a></p><p>給定長度為 $n$ 的數列 $a$，每次操作可以選擇數列中的一個數字 $a_i$，使其 $+1$ 或 $-1$。問使 $a$ 數列非嚴格遞增的最少操作次數？</p><ul><li>$1 \leq n \leq 2 \cdot 10^5$</li><li>$1 \leq a_i \leq 10^9$</li></ul></blockquote><p>先從最基本的 $dp$ 下手。定義 $dp[i][j]$ 為使 $a_1, \dots, a_i$ 非嚴格遞增且 $a_i = j$ 的最少操作次數。我們可以列出 $dp$ 的轉移式：</p><p>\begin{cases}<br>dp[1][j] &amp;= |a_1 - j| &amp; \text{base case} \\<br>dp[i][j] &amp;= \min\limits_{k \leq j} \{ dp[i - 1][k] + |a_i - j| \}, i &gt; 1 &amp; \text{轉移} \\<br>\end{cases}</p><p>由上述的轉移不難看出 $dp[i]$ 為 Slope Trickable Function。</p><p>最後的答案就是 $dp[n]$ 函數的最小值，也就是 $\min\limits_{j} dp[n][j]$</p><p>因為 $dp$ 為凸函數，函數的最小值會發生在斜率為 $0$ 的區段，這是我們想要維護的資訊。</p><p>先從 base case 出發。可以發現 $|x - a_1|$ 函數在斜率 $&gt; 0$ 的區段只會讓答案變得更差，並且使後續的數字更難滿足條件，因此我們可以把這個區段的斜率壓平成 $0$。</p><table><thead><tr><th align="center"><img src="/posts/slope-trick/example-1-01.png" alt="example-1-01.png"></th><th align="center"><img src="/posts/slope-trick/example-1-02.png" alt="example-1-02.png"></th></tr></thead><tbody><tr><td align="center">$|x - a_1|$ 函數圖形</td><td align="center">把斜率 $&gt; 0$ 的區段壓平</td></tr></tbody></table><p>接下來我們來看如何從 $dp[i - 1]$ 轉移到 $dp[i]$。假設 $dp[i - 1]$ 最右邊的分段點為 $p$，分成兩種 case：</p><ol><li>$p \leq a_i$：函數的最小值沒有改變，新增一個分段點在 $a_i$。</li></ol><table><thead><tr><th align="center"><img src="/posts/slope-trick/example-1-03.png" alt="example-1-03.png"></th><th align="center"><img src="/posts/slope-trick/example-1-04.png" alt="example-1-04.png"></th><th align="center"><img src="/posts/slope-trick/example-1-05.png" alt="example-1-05.png"></th></tr></thead><tbody><tr><td align="center">新增 $|x - a_i|$</td><td align="center">合併函數</td><td align="center">把斜率 $&gt; 0$ 的區段壓平</td></tr></tbody></table><ol start="2"><li>$p &gt; a_i$：函數的最小值增加 $|p - a_i|$，移除 $p$ 的分段點，並在 $a_i$ 加入兩次分段點。</li></ol><table><thead><tr><th align="center"><img src="/posts/slope-trick/example-1-06.png" alt="example-1-06.png"></th><th align="center"><img src="/posts/slope-trick/example-1-07.png" alt="example-1-07.png"></th><th align="center"><img src="/posts/slope-trick/example-1-08.png" alt="example-1-08.png"></th></tr></thead><tbody><tr><td align="center">新增 $|x - a_i|$</td><td align="center">合併函數，函數的最小值增加 $p - a_i$</td><td align="center">把斜率 $&gt; 0$ 的區段壓平</td></tr></tbody></table><p>維護函數的分段點，並用一個變數紀錄斜率 $= 0$ 的高度即可。</p><details><summary>Solution Code</summary><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br>priority_queue&lt;<span class="hljs-type">int</span>&gt; pq;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br><span class="hljs-type">int</span> x;<br>cin &gt;&gt; x;<br><span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">empty</span>() || x &gt; pq.<span class="hljs-built_in">top</span>()) {<br>pq.<span class="hljs-built_in">push</span>(x);<br>} <span class="hljs-keyword">else</span> {<br>ans += pq.<span class="hljs-built_in">top</span>() - x;<br>pq.<span class="hljs-built_in">pop</span>();<br>pq.<span class="hljs-built_in">push</span>(x);<br>pq.<span class="hljs-built_in">push</span>(x);<br>}<br>}<br>cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">"\n"</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></details><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ul><li><a href="https://codeforces.com/contest/713/problem/C">CF 713C - Sonya and Problem Wihtout a Legend</a></li><li><a href="https://atcoder.jp/contests/arc070/tasks/arc070_c">ARC070 E - NarrowRectangles</a></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://codeforces.com/blog/entry/47094#comment-315161">https://codeforces.com/blog/entry/47094?#comment-315161</a></li><li><a href="https://maspypy.com/slope-trick-1-%E8%A7%A3%E8%AA%AC%E7%B7%A8">maspypy - Slope Trick</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Slope Trick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【題解】ABC302 Ex - Ball Collector</title>
      <link href="/posts/abc302h/"/>
      <url>/posts/abc302h/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc302/tasks/abc302_h">題目連結</a></p><h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><p>給定一棵樹，樹上的每個節點有兩個數字 $A_i, B_i$。每經過節點時，可以從節點上的兩個數字任意拿走一個。對於 $v = 2, \dots N$，求從 $1$ 走到 $v$ 的最短路徑上，最多可以拿到幾種相異的數字？</p><ul><li>$2 \leq N \leq 2 \cdot 10^5$</li><li>$1 \leq A_i, B_i \leq N$</li></ul><h2 id="觀察"><a href="#觀察" class="headerlink" title="觀察"></a>觀察</h2><p><a href="https://atcoder.jp/contests/arc111/tasks/arc111_b">這題</a>是本題的簡單版本，也就是當樹是一條鏈的情況。我們建一張新的圖 $G$，把 $A_i$ 和 $B_i$ 當作節點，並對每對 $A_i, B_i$ 連接邊，題目就簡化為：對於每條邊，選擇其中一端的節點，問最多可以選到幾個節點？</p><p>如果 $G$ 有多個連通塊，因為每個連通塊之間互相獨立，我們可以分別對每個連通求出答案再加起來。因此這邊只考慮 $G$ 是一個連通塊的情況。考慮兩種情況：</p><ol><li>如果 $G$ 是一棵樹，則我們可以選到 $N - 1$ 個節點。構造的方法就是隨意選擇一個節點作為樹根，對於每條邊我們都選擇深度比較深的那個節點。這樣每個邊都不會選到重複的節點，又因為選擇的節點數量不能超過邊的數量，因此 $N - 1$ 是上限。</li><li>如果 $G$ 邊的數量超過 $N$，則我們可以選到全部 $N$ 個節點。構造方法就是先對 $G$ 建立一棵生成樹，把任意一條多餘的邊的一端作為生成樹的樹根，根據 1. 生成樹上除了樹根以外的節點都可以被選到，最後再對於這條邊選擇生成樹的根節點。這樣一來 $N$ 個節點都可以被選到。</li></ol><p>在上述的做法中，我們希望可以維護每個連通塊的節點和邊的數量。</p><p>在這題中，我們直接用走 DFS 序。每當我們進入一個新的節點 $i$ 時，要把 $A_i$ 和 $B_i$ 連邊，離開 $i$ 時要把這條邊斷開，並同時維護每個連通塊的資訊。要動態維護這些資訊我們可以用 <del>Link Cut Tree</del> 回滾並查集！DFS 進入一個節點的時候，先記錄並查集當前的狀態，離開前再回滾回去。</p><p>DFS 的時間複雜度為 $O(N)$，回滾並查集的合併是 $O(\log N)$，回滾為 $O(1)$，因此總時間複雜度為 $O(N \log N)$</p><p><a href="https://atcoder.jp/contests/abc302/submissions/41589083">Solution Code</a></p>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 並查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【筆記】Aliens 優化</title>
      <link href="/posts/aliens-optimization/"/>
      <url>/posts/aliens-optimization/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>有些題目要求進行 $k$ 次操作的最大/最小值。我們開心的列出 $dp[i][j]$ 為前 $i$ 個東西進行 $j$ 次操作的最大值，答案就是 $dp[n][k]$，但很不幸的 $O(nk)$ 會超時，這時候我們或許能套用 Aliens 優化。</p><p><strong>Definition.</strong> $f(k)$ 為進行 $k$ 次操作的最大值。</p><p>$f$ 必須是一個凹函數 (concave function) 才能套用 Aliens 優化 (如果改成求最小值的話則必須是凸函數)。凹函數的斜率非嚴格遞減，也就是說每多進行一次操作，數值增加的幅度會越來越少。</p><p>$$f(k + 1) - f(k) \leq f(k) - f(k - 1)$$</p><p><strong>Lemma.</strong> 定義 $g_p(k) = f(k) - kp$，則 $g_p$ 也是凹函數。</p><p><strong>Proof.</strong> 根據 $g_p$ 的定義，我們可以列出：</p><p>\begin{aligned}<br>g_p(k + 1) - g_p(k) &amp;= (f(k + 1) - (k + 1)p) - (f(k) - kp) \\<br>&amp;= f(k + 1) - f(k) - p \\<br>&amp; \leq f(k) - f(k - 1) - p \\<br>&amp;= (f(k) - kp) - (f(k - 1) - (k - 1)p) \\<br>&amp;= g_p(k) - g_p(k - 1) \\<br>\iff g_p(k + 1) - g_p(k) &amp; \leq g_p(k) - g_p(k - 1)<br>\end{aligned}</p><p>因此 $g_p$ 也是凹函數。</p><p>$g_p(k) = f(k) - kp$ 可以想像成對於每筆操作，我們額外收取 $p$ 元的手續費。當 $p$ 越大，$g_p(k)$ 最大值發生的位置 $k$ 會越往左邊靠 (可以想成手續費太貴，所以不進行那麼多次操作)，當 $p$ 越小，最大值發生的位置會越往右靠 (手續費太便宜，多進行幾次操作不會虧錢)。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="可以參考 Reference 1. 的 gif，其中藍色的函數就是 $g_p(k)$。">[1]</span></a></sup></p><p>有了以上的概念，我們就可以對 $p$ 進行二分搜，讓 $g_p(k)$ 最大值發生的位置剛好落在 $k$，也就是操作 $k$ 次，這樣我們就可以回頭算出 $f(k) = g_p(k) + kp$ 了！如果 $f(k)$ 的定義改成最小值的話就改成 $g_p(k) = f(k) + kp$，也能用同樣的邏輯求出。</p><p>其他實作的細節可以參考 <a href="#Reference">Reference</a> 的文章。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>找最小值的話記得把 $+kp$ 改成 $-kp$。<br><code>Func f</code> 為一個函式，回傳值為 <code>{最大/最小值, 最少操作次數}</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 找最大值</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Aliens</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> l, <span class="hljs-type">long</span> <span class="hljs-type">long</span> r, <span class="hljs-type">int</span> k, Func f)</span> </span>{<br><span class="hljs-keyword">while</span>(l &lt; r) {<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> [score, op] = <span class="hljs-built_in">f</span>(m);<br><span class="hljs-keyword">if</span>(op == k) {<br><span class="hljs-keyword">return</span> score + m * k;<br>}<br><span class="hljs-keyword">if</span>(op &lt; k) {<br>r = m;<br>} <span class="hljs-keyword">else</span> {<br>l = m + <span class="hljs-number">1</span>;<br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(l).first + l * k;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="例題"><a href="#例題" class="headerlink" title="例題"></a>例題</h2><p>底下的例題 $dp$ 應該要是 {最大/最小值, 最少操作次數}，方便起見只寫最大/最小值，實作時記得要計算操作次數。$\Phi$ 為每筆操作而外收的手續費。</p><blockquote><p><a href="https://tioj.ck.tp.edu.tw/problems/2039">TIOJ - AI-666 賺多少</a></p><p>已知 $n$ 個時間點股票的價格，手上沒有股票的話才能買入，有股票才能賣出。求買賣 $k$ 次的最大利益？</p><ul><li>$1 &lt; n \leq 2 \cdot 10^6$</li><li>$k \leq n$</li></ul></blockquote><p>本題有 greedy 解，但我們練習用 Aliens 優化來做。</p><p>定義 $f(k)$ 為做 $k$ 次交易的最大收益。可以觀察到 $f$ 是凹函數，因為如果第 $k$ 筆交易的獲益比第 $k - 1$ 次多，我們可以交換交易的順序，把 $k - 1$ 多做的那次換成 $k$ 多做的那次。</p><p>定義 $dp$：</p><ul><li>$dp_0[i]$ = 時間 $i$ 時手上<strong>沒有</strong>股票的最大收益</li><li>$dp_1[i]$ = 時間 $i$ 時手上<strong>持有</strong>股票的最大收益</li></ul><p>轉移就會是：</p><p>\begin{aligned}<br>dp_0[i] &amp;= \max(dp_0[i - 1], dp_1[i - 1] + a[i] - \Phi) \\<br>dp_1[i] &amp;= \max(dp_1[i - 1], dp_0[i - 1] - a[i])<br>\end{aligned}</p><p>計算一次 $dp$ 的時間為 $O(n)$，因此總時間複雜度為 $O(n \log C)$ (以下皆用 $C$ 表示 Aliens 二分搜的範圍)。</p><details><summary>Solution Code</summary><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// find maximum</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Aliens</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> l, <span class="hljs-type">long</span> <span class="hljs-type">long</span> r, <span class="hljs-type">int</span> k, Func f)</span> </span>{<br><span class="hljs-keyword">while</span>(l &lt; r) {<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> [score, op] = <span class="hljs-built_in">f</span>(m);<br><span class="hljs-keyword">if</span>(op == k) {<br><span class="hljs-keyword">return</span> score + m * k;<br>}<br><span class="hljs-keyword">if</span>(op &lt; k) {<br>r = m;<br>} <span class="hljs-keyword">else</span> {<br>l = m + <span class="hljs-number">1</span>;<br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(l).first + l * k;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n, k;<br>cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>cin &gt;&gt; a[i];<br>}<br><span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">long</span> <span class="hljs-type">long</span> p) {<br>pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; dp0 = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>};<br>pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; dp1 = {INT_MIN, <span class="hljs-number">0</span>};<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; new_dp0 = <span class="hljs-built_in">max</span>(dp0, pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;{dp1.first + a[i] - p, dp1.second - <span class="hljs-number">1</span>});<br>pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; new_dp1 = <span class="hljs-built_in">max</span>(dp1, pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;{dp0.first - a[i], dp0.second});<br><span class="hljs-built_in">swap</span>(dp0, new_dp0);<br><span class="hljs-built_in">swap</span>(dp1, new_dp1);<br>}<br>dp0.second = -dp0.second;<br><span class="hljs-keyword">return</span> dp0;<br>};<br>cout &lt;&lt; <span class="hljs-built_in">Aliens</span>(<span class="hljs-number">0</span>, (<span class="hljs-type">int</span>) <span class="hljs-number">1E8</span>, k, f) &lt;&lt; <span class="hljs-string">"\n"</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></details><blockquote><p><a href="https://cses.fi/problemset/task/2086">CSES - Subarray Squares</a></p><p>把長度為 $n$ 的數列切成 $k$ 段，一段的費用是和的平方，求最小費用和？</p><ul><li>$1 \leq k \leq n \leq 3000$</li></ul></blockquote><p>定義 $f(k)$ 為切成 $k$ 段的最小費用和。固定切割的位置，切割的先後順序不會影響答案，我們可以讓影響最小的那次切割作為第 $k$ 次，因此 $f$ 是一個凸函數。</p><p>定義 $dp[i]$ 為只考慮前 $i$ 個數字的最小費用和，轉移就會是：</p><p>$$dp[i] = \min_{j \leq i} (dp[j - 1] + (\sum_{k = j}^{i} a[i])^2 + \Phi)$$</p><p>注意 $dp$ 轉移裡的 $\Phi$ 係數為正，因為我們的目標是找最小值。</p><p>時間複雜度：$O(n^2 \log C)$</p><details><summary>Solution Code</summary><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// find minimum</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Aliens</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> l, <span class="hljs-type">long</span> <span class="hljs-type">long</span> r, <span class="hljs-type">int</span> k, Func f)</span> </span>{<br><span class="hljs-keyword">while</span>(l &lt; r) {<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> [score, op] = <span class="hljs-built_in">f</span>(m);<br><span class="hljs-keyword">if</span>(op == k) {<br><span class="hljs-keyword">return</span> score - m * k;<br>}<br><span class="hljs-keyword">if</span>(op &lt; k) {<br>r = m;<br>} <span class="hljs-keyword">else</span> {<br>l = m + <span class="hljs-number">1</span>;<br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(l).first - l * k;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n, k;<br>cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>cin &gt;&gt; a[i];<br>}<br><span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">pref</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>pref[i + <span class="hljs-number">1</span>] = pref[i] + a[i];<br>}<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> INF = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) <span class="hljs-number">1E18</span>L + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">long</span> <span class="hljs-type">long</span> cost) -&gt; pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; {<br>vector&lt;pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;{INF, <span class="hljs-number">0</span>});<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; --j) {<br><span class="hljs-keyword">auto</span> cur = (j &gt; <span class="hljs-number">0</span> ? dp[j - <span class="hljs-number">1</span>] : pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;{<span class="hljs-number">0</span>, <span class="hljs-number">0</span>});<br>cur.first += (pref[i + <span class="hljs-number">1</span>] - pref[j]) * (pref[i + <span class="hljs-number">1</span>] - pref[j]) + cost;<br>cur.second += <span class="hljs-number">1</span>;<br>dp[i] = <span class="hljs-built_in">min</span>(dp[i], cur);<br>}<br>}<br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>};<br>cout &lt;&lt; <span class="hljs-built_in">Aliens</span>(<span class="hljs-number">0</span>, INF, k, f) &lt;&lt; <span class="hljs-string">"\n"</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></details><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ul><li><a href="https://zerojudge.tw/ShowProblem?problemid=h926">ZJ - 美食博覽會 (k 值加大版)</a></li><li><a href="https://cses.fi/problemset/task/2087/">CSES - Houses and Schools</a></li><li><a href="https://codeforces.com/contest/1279/problem/F">CF 1279F - New Year and Handle Change</a></li><li><a href="https://tioj.ck.tp.edu.tw/problems/1986">TIOJ - 郵局設置問題 $\infty$ EXTREME</a></li><li><a href="https://ioinformatics.org/files/ioi2016problem6.pdf">IOI 2016 - Aliens</a></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://cp.wiwiho.me/aliens/">[WiwiHo 的競程筆記] Aliens 優化</a></li><li><a href="https://tioj.ck.tp.edu.tw/uploads/attachment/5/51/10.pdf">[2016建中校內培訓講義] Aliens 優化</a></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>可以參考 Reference 1. 的 gif，其中藍色的函數就是 $g_p(k)$。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aliens 優化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【題解】Codeforces 1780F Three Chairs</title>
      <link href="/posts/cf-1780f/"/>
      <url>/posts/cf-1780f/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1780/problem/F">題目連結</a></p><h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><p>給定一個長度為 $n$ 的數列 $a$，求：</p><p>$$\sum_{i = 0}^{n - 1} \sum_{j = i + 1}^{n - 1} \sum_{k = j + 1}^{n - 1} [\gcd(\min(a_i, a_j, a_k), \max(a_i, a_j, a_k)) = 1]$$</p><p>其中 $[P]$ 是<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BD%9B%E6%A3%AE%E6%8B%AC%E5%8F%B7">艾佛森括號</a>。</p><ul><li>$3 \leq n \leq 3 \cdot 10^5$</li><li>$1 \leq a_i \leq 3 \cdot 10^5$</li><li>$a_i \neq a_j, i \neq j$</li></ul><h2 id="觀察"><a href="#觀察" class="headerlink" title="觀察"></a>觀察</h2><p>$\mu$ 為<a href="https://oi-wiki.org/math/number-theory/mobius/">莫比烏斯函數</a>，具有以下的性質：<br>$$<br>\sum_{d | n} \mu(d) = [n = 1] =<br>\begin{cases}<br>    0 &amp; n \neq 1 \\<br>    1 &amp; n = 1<br>\end{cases}<br>$$</p><p>我們令 $A = \max(a)$ 為值域。<br>利用莫比烏斯函數的性質，我們可以把原本的式子轉換為：</p><p>$$<br>\begin{aligned}<br>&amp;= \sum_{i = 0}^{n - 1} \sum_{j = i + 1}^{n - 1} \sum_{k = j + 1}^{n - 1} \sum_{d | \gcd(\min(a_i, a_j, a_k), \max(a_i, a_j, a_k))} \mu(d) \\<br>&amp;= \sum_{d = 1}^{A} \mu(d) \sum_{i = 0}^{n - 1} \sum_{j = i + 1}^{n - 1} \sum_{k = j + 1}^{n - 1} ([d | \min(a_i, a_j, a_k)][d | \max(a_i, a_j, a_k)])<br>\end{aligned}<br>$$</p><p>可以發現後面那項其實就是在求有幾組 $i &lt; j &lt; k$ 滿足 $a_i &lt; a_j &lt; a_k$ 且 $a_i$ 和 $a_k$ 是 $d$ 的倍數，枚舉 $d$ 的倍數後可以輕易求出。</p><p>莫比烏斯函數可以用<a href="https://oi-wiki.org/math/number-theory/sieve/#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95">線性篩</a>在 $O(A)$ 求出，而所有倍數的個數為 $\sum\limits_{d = 1}^{A} \lfloor \frac{A}{d} \rfloor \approx O(A \log A)$，總時間複雜度為 $O(n + A \log A)$。</p><p><a href="https://codeforces.com/contest/1780/submission/190633405">Solution Code</a></p>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比烏斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【題解】CSES - One Bit Positions</title>
      <link href="/posts/cses-2112/"/>
      <url>/posts/cses-2112/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cses.fi/problemset/task/2112/">題目連結</a></p><h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><p>給定一個長度為 $n$ 由 $\text{‘0’, ‘1’}$ 組成的字串 $S$，對於 $k = 1, \dots, n - 1$，求出有幾組 $i, j$ 滿足 $i - j = k$ 且 $S_i = S_j = \text{‘1’}$。</p><ul><li>$2 \leq n \leq 2 \cdot 10^5$</li></ul><h2 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h2><p>先將字串轉換成多項式的形式表示 ($\text{“10011”} \to 1x^0 + 0x^1 + 0x^2 + 1x^3 + 1x^4$)。假設轉換成多項式 $A = \sum\limits_{i = 0}^{n - 1} a_i x^i$，我們要求的是對於所有 $1 \leq k \leq n - 1$，$c_k = \sum\limits_{i - j = k} a_i a_j$。</p><p>觀察到如果 $i - j = k$，那麼 $i + (n - 1 - j) = n - 1 + k$。</p><p>建立 $B = \sum\limits_{i = 0}^{n - 1} a_{n - 1 - i} x^i$，答案就會是多項式 $A$ 和 $B$ 的卷積 $P$，$k$ 的答案即為$[x^{n - 1 + k}]P$。</p><p>由於 $n \leq 10^5$，$O(n^2)$ 的多項式卷積會 TLE，可以使用 <a href="https://oi-wiki.org/math/poly/fft/">FFT</a> 或是 <a href="https://oi-wiki.org/math/poly/ntt/">NTT</a> 在 $O(n \log n)$ 求出。</p><details><summary>Solution Code</summary><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> cd = complex&lt;<span class="hljs-type">double</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>); <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(vector&lt;cd&gt;&amp; a, <span class="hljs-type">bool</span> inv)</span> </span>{<br><span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) a.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br><span class="hljs-type">int</span> bit = n &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(; j &amp; bit; bit &gt;&gt;= <span class="hljs-number">1</span>) {<br>j ^= bit;<br>}<br>j ^= bit;<br><span class="hljs-keyword">if</span>(i &lt; j) {<br><span class="hljs-built_in">swap</span>(a[i], a[j]);<br>}<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len &lt;&lt;= <span class="hljs-number">1</span>) {<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ang = <span class="hljs-number">2</span> * PI / len * (inv ? <span class="hljs-number">-1</span> : +<span class="hljs-number">1</span>);<br><span class="hljs-function">cd <span class="hljs-title">rot</span><span class="hljs-params">(cos(ang), sin(ang))</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += len) {<br><span class="hljs-function">cd <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len / <span class="hljs-number">2</span>; ++j) {<br>cd u = a[i + j], v = a[i + j + len / <span class="hljs-number">2</span>] * w;<br>a[i + j] = u + v;<br>a[i + j + len / <span class="hljs-number">2</span>] = u - v;<br>w *= rot;<br>}<br>}<br>}<br><span class="hljs-keyword">if</span>(inv) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x : a) {<br>x /= n;<br>}<br>}<br>}<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br><span class="hljs-function">vector&lt;cd&gt; <span class="hljs-title">fa</span><span class="hljs-params">(a.begin(), a.end())</span></span>;<br><span class="hljs-function">vector&lt;cd&gt; <span class="hljs-title">fb</span><span class="hljs-params">(b.begin(), b.end())</span></span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n &lt; (<span class="hljs-type">int</span>) a.<span class="hljs-built_in">size</span>() + (<span class="hljs-type">int</span>) b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {<br>n &lt;&lt;= <span class="hljs-number">1</span>;<br>}<br>fa.<span class="hljs-built_in">resize</span>(n);<br>fb.<span class="hljs-built_in">resize</span>(n);<br><span class="hljs-built_in">FFT</span>(fa, <span class="hljs-literal">false</span>);<br><span class="hljs-built_in">FFT</span>(fb, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>fa[i] *= fb[i];<br>}<br><span class="hljs-built_in">FFT</span>(fa, <span class="hljs-literal">true</span>);<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(a.size() + b.size() - <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>) c.<span class="hljs-built_in">size</span>(); ++i) {<br>c[i] = <span class="hljs-built_in">round</span>(fa[i].<span class="hljs-built_in">real</span>());<br>}<br><span class="hljs-keyword">return</span> c;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>string s;<br>cin &gt;&gt; s;<br><span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) s.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>a[i] = b[n - <span class="hljs-number">1</span> - i] = s[i] - <span class="hljs-string">'0'</span>;<br>}<br><span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">multiply</span>(a, b);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) {<br>cout &lt;&lt; c[n - <span class="hljs-number">1</span> + i] &lt;&lt; <span class="hljs-string">" \n"</span>[i == n - <span class="hljs-number">1</span>];<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> CSES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【心得】2022 ICPC Asia Taoyuan Regional 心得</title>
      <link href="/posts/icpc-2022-taoyuan/"/>
      <url>/posts/icpc-2022-taoyuan/</url>
      
        <content type="html"><![CDATA[<h2 id="11-x2F-19"><a href="#11-x2F-19" class="headerlink" title="11/19"></a>11/19</h2><p>這次比賽的地點在桃園的武漢國中，蠻偏僻的，但是裡面冷氣超涼。我們的座位後面是零食區和廁所，旁邊是點心區，超方便。今年的衣服是粉紅色的，材質穿起來很透氣舒服，背包看起來也不錯 (聽說某年的背包背一下子就壞掉了)。<br>今天主要是 測機X 認親大會O，還被別校同學採訪 (然後我們就直接推薦小褲褲那隊 hehe)。有趣的事情是有工作人員看到我們的隊名問我們隊是不是有吳邦寧，看來是隊名取的太毒瘤了。<br>上次原本打完 NCPC 決賽說要多練幾場的，結果因為期中接踵而來，根本沒時間練習。將近一整個月沒碰競程，昨天跑去 virtual 去年 Regional 的題目，結果只寫了三題就跑去睡覺了，超諧。今年台大報了 $14$ 隊，交大報了 $10$ 隊，清大 $7$ 隊，希望明天不要燒雞。</p><h2 id="11-x2F-20-比賽"><a href="#11-x2F-20-比賽" class="headerlink" title="11/20 比賽"></a>11/20 比賽</h2><p>開場我先打 vimrc 和 default code，隊友讀題目。過了不久，林立上就把 pM 丟給我了，是 DSU 的裸題。我馬上打好然後送出。</p><p>$\text{[0:06] pM }\color{red}{\text{WA}}$</p><p>傻眼，我笨到連 DSU 都不會刻了嗎？後來發現原來他題目的範圍給錯，前面寫 0-based 後面寫 1-based。改了一下之後就 AC 了。</p><p>$\text{[0:09] pM }\color{green}{\text{AC}}$</p><p>就這樣莫名其妙被坑了一個 penalty ==。pC 也是水題，求逆序數對的數量，然後 $N \leq 100$。我就直接寫了最簡單的 Bubble Sort。</p><p>$\text{[0:13] pC }\color{green}{\text{AC}}$</p><p>這時候我們又開了兩題，pA 很水，但是打表要花一段時間。pG 是很水的字串匹配題，暴力就可以過了，所以我就先去把 pG 寫掉。</p><p>$\text{[0:27] pG }\color{green}{\text{AC}}$</p><p>接著我回去抄 pA 的表，打了好久終於打完了，測了一下範測有過就直接丟了。</p><p>$\text{[0:35] pA }\color{red}{\text{WA}}$</p><p>應該是打錯表了，我請林立上幫忙檢查，我去讀其他題目。結果原來我把 C 跟 G 看反，然後範測又剛好沒有這個 case，改好之後再丟一次。</p><p>$\text{[0:39] pA }\color{green}{\text{AC}}$</p><p>這時候記分板上面都跟我們一樣 $4$ 題，這代表我們要去開新的題目。pB 是數學題，pD 是閱讀題，pJ 跟 pF 是實作題。這些是看起來比較可做的，我也不知道哪來的自信先去做數學題。做完之後就直接丟，很顯然我的唬爛解是不可能會過的。</p><p>$\text{[0:57] pB }\color{red}{\text{WA}}$</p><p>這時候隊友說 pD 好像暴力做 $O(N^2)$ 就會過了，然後我看到那個 $N \leq 10000$ 就有點怕，不過測機的時候 judge $1$ 秒大改可以跑 $5e8$，然後這題開三秒，應該沒問題。所以就先把 pD 給游承桓做，我繼續推 pB 的公式。</p><p>$\text{[1:16] pD }\color{red}{\text{WA}}$</p><p>吃 WA 了，debug 把過程印出來後發現題目附的圖跟說明不符合，於是林立上就送了 Clarification 去問，結果真的是畫錯了。後來 debug 發現是改了寫法後有個地方沒有更改到，修改完後就 AC 了。</p><p>$\text{[2:35] pD }\color{green}{\text{AC}}$</p><p>到這邊我們剛好第 $30$ 名，在銀牌線上。pJ 蠻水的可是實作的 case 超多，pB 公式還沒推出來，所以我就去寫 pJ。因為會用到線段樹我就開始打開 Codebook 抄，被游承桓說我用的 zkw 線段樹左閉右開區間很毒瘤。我們一邊判 case，林立上繼續想 pB。</p><p>$\text{[3:38] pJ }\color{red}{\text{WA}}$</p><p>case 應該都有判到，所以我判斷是查詢的區間寫爛了。果真我有個地方忘記 $+1$。</p><p>$\text{[3:50] pJ }\color{red}{\text{WA}}$</p><p>又有地方忘記 $+1$，好粗心，改完之後就 AC 了。</p><p>$\text{[3:57] pJ }\color{green}{\text{AC}}$</p><p>這時候我們排名大概在 $26$ 附近，要穩銀牌一定要做出 pB。<br>pB 我們卡在：數 $N$ 個點圍成一圈，每個點塗上 $K$ 種顏色的其中一種，求相鄰點顏色不相同的方法數有幾種？後來打算用排容，發現剛好會形成等比級數，打好之後過了範測，又測了小 case 沒問題後就丟了。</p><p>$\text{[4:32] pB }\color{green}{\text{AC}}$</p><p>AC 了超開心，剩下的時間應該也不夠再寫出一題了，所以就跑去旁邊的點心區拿東西吃。</p><h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><p>AC：$7/13$<br>penalty：$872$<br>Rank $25$</p><p>第 $24$ 名也是清大的隊伍，但我們的 penalty 太高了，下次要再細心一點。<br>這次清大成績 $2$ 金 $2$ 銀 $2$ 銅，超棒！<br>大一上學期的競程之旅應該就到這邊了，接下來要繼續被考試轟炸到期末了。寒假有時間的話多練習，看能不能拚個金牌。</p><p>喔然後不要亂立 flag。</p>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【心得】2022 NCPC 校內賽心得</title>
      <link href="/posts/ncpc-2022-pre/"/>
      <url>/posts/ncpc-2022-pre/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>比賽前又失眠了，三點才睡著，八點半就爬起來但是卻意外的有精神。</p><p>校內賽前我們只有線上 virtual 過一次 (而且還偷懶沒有打滿 $5$ 小時)，甚至到今天我才第一次見到隊友林立上本人。</p><p>有好多隊伍都有人確診或隔離沒辦法比賽，像李佳樺超可憐直接變成單刷，也讓我們晉級的機會變大？</p><p>因為沒有準備 Codebook，所以直接用 <a href="https://github.com/brianbbsu/8BQube">BBQube</a> 的，但好多我們根本不會的模板 QQ。</p><h2 id="比賽"><a href="#比賽" class="headerlink" title="比賽"></a>比賽</h2><p><a href="https://drive.google.com/file/d/1UqtLTLxI16I2fuTF4bv4pdcLh0ixmlnd/view">題本連結</a><br><a href="https://hackmd.io/@redleaf23477/nthu-ncpc-pre-2022">題解</a></p><p>開場我先打 default code，游承桓跟林立上先讀題目。</p><p>很快游承桓就把 pA 丟給我了，是一道簽到題。</p><p>$\text{[0:06] pA }\color{green}{\text{AC}}$</p><p>林立上從後面看，發現 pK 也是水題，要輸出謝爾賓斯基碎形。</p><p>這題是遞迴的經典題，但卡了一點時間，因為我耍笨只輸出 $N$ 行，應該要輸出 $3^N$ 行。</p><p>$\text{[0:22] pK }\color{green}{\text{AC}}$ (首殺)</p><p>還蠻意外在卡了那麼久之後還能拿到這題的首殺</p><p>游承桓發現 pD 是中國剩餘定理的裸題，所以我就很開心的從 Codebook 抄了 <code>extgcd</code> 跟 <code>crt</code> 的模板，然後 submit。</p><p>$\text{[0:35] pD }\color{red}{\text{WA}}$</p><p>我以為是 <code>crt</code> 小的要放前面的問題，所以修改了之後又上傳一次。</p><p>$\text{[0:40] pD }\color{red}{\text{WA}}$</p><p>我們把 code 列印下來檢查是不是模板抄錯，也寫了暴力對拍都是對的，沒有找到 bug，所以就先跑去開 pG。</p><p>pG 一開始寫了五層的迴圈，但沒有注意到抽 $5$ 張牌是同時，與順序無關，所以以為這個方法行不通，因此跑去寫了 DP 的解，然後丟上去。</p><p>$\text{[0:45] pG }\color{red}{\text{WA}}$</p><p>一開始以為這題是 Output only，因為題本上似乎沒給範例測資，但後來有發現 judge 上面有測資可以下載，所以就稍微修改了一下然後上傳。</p><p>$\text{[0:59] pG }\color{green}{\text{AC}}$</p><p>賽後助教說 pG 的首殺跟官解都是直接用五層迴圈，顯然我在吃毒。</p><p>之後我們又開了很多題，pF 看起來是 flow，但是沒有想到要怎麼建圖。pH 是噁心的模擬題，要處理的細節蠻多的。pB 以為是奇怪的斜率優化 DP。</p><p>又過了一個小時後，我們決定把 pD 改成 <code>__int128</code> 試試看，雖然題目保證答案不超過 $2^{31}$ (一開始想說 <code>long long</code> 應該就夠了)。</p><p>$\text{[1:57] pD }\color{green}{\text{AC}}$</p><p>AC 後反而一臉矇逼？！</p><p>pH 雖然噁心，但是看起來是目前比較有機會做出來的題目，因此為了判斷 pH 的線段相交，我們從 Codebook 抄了將近 $100$ 行的模板，但是寫一寫就半放棄了，實作好噁心。</p><p>pE 可以發現對於一個連通塊 (高度相同) 他們的 spawn 值必定相同，並且一個點如果可以是 spawn 點，那麼該連通塊上所有高度比他小的的鄰居必須全部都是 spawn 點。<br>因此我刻了 DSU 來維護連通塊，再對高度做排序，由低往高枚舉，實作起來其實蠻乾淨的。</p><p>$\text{[2:50] pE }\color{green}{\text{AC}}$</p><p>耶，一發 AC！我們的排名也回到第 $5$ 名，第 $6$ 名跟我們 penalty 差不到 $20$ 分鐘。</p><p>這時候差不多封板了，pB 跟 pH 蠻多隊寫出來。</p><p>pB 我寫了從後面回推的 greedy，但很快被隊友發現是假解。後來林立上提出另一個 greedy，從對答案的貢獻下手。我們用這個方法試了範例測資都是對的，所以就跑去寫寫看。</p><p>$\text{[4:22] pB }\color{green}{\text{AC}}$</p><p>林立上 orz，想不到這樣就過了，難怪那麼多組比我們早寫出來，賽後題解出來也被證實這是一道水題，完全是我們想得太複雜了 (其實是古老 ABC round 的題目直接搬過來的)</p><p>剩下的時間就都拿去寫 pH 了，雖然範測有過，但是送出去後吃 WA 也沒有頭緒。賽後推測可能是因為 $K \leq 10^{18}$ 然後內積和外積都有乘法所以有可能會 overflow。</p><h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><p>AC：$6/11$<br>penalty：$756$<br>Rank $5$</p><p>結果 pF 真的是 flow，但要用到我還不會的 Konig’s Theorem。</p><p>開板後維持在 Rank $5$，第 $6$ 名的 penalty 只多我們 $30$ 分鐘，不過在開板前大概就有猜到可以晉級，因為後面沒有 $6$ 題的。</p><p>接下來 10/15 就要打 NCPC 決賽了，希望中間這段時間可以多 virtual 個幾場 (如果 NCPC 決賽不幸燒雞還有 TOPC 可以打)。</p>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【題解】NPSC 2020 pA 邊緣人</title>
      <link href="/posts/npsc-2020-a/"/>
      <url>/posts/npsc-2020-a/</url>
      
        <content type="html"><![CDATA[<p><a href="https://contest.cc.ntu.edu.tw/npsc2020/teamclient/semi_senior.pdf">題目連結</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>NPSC 是我參加的第一場比賽，理所當然的被打爆，只解出最水的 pB。當時跟隊友花了很多時間在解這題，但是由於數學知識不足，都在原地打轉。最近剛好翻到這題，想說花點時間想一下，馬上就有了突破，也順利 AC，算是彌補了當時的遺憾。</p><h2 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h2><p>有 $n$ 個人要分組，一組 $x$ 個人，編號 $1$ 到 $x$ 的人會分到一組，$(x + 1)$ 到 $2x$ 會分到一組，依此類推。最後可能會有一些人組員人數不足 $x$，我們稱這些人為邊緣人。我們定義編號 $i$ 的人的邊緣值 $f(i)$ 為：在 $x = 1, x = 2, \dots , x = n$ 這 $n$ 個情況中，編號 $i$ 的人成為邊緣人的情況總數。<br>給定 $L, R$，請求出 $f(L), f(L + 1), \dots , f(R)$。</p><ul><li>$1 \leq n \leq 2^{40}$</li><li>$L \leq R \leq n$</li><li>$R − L \leq 3 \cdot 10^5$</li></ul><h2 id="觀察"><a href="#觀察" class="headerlink" title="觀察"></a>觀察</h2><p>$f(i)$ 可以改寫為：</p><p>$$f(i) = \sum_{g = 1}^n [\lfloor \frac{n}{g} \rfloor \cdot g &lt; i]$$</p><p>其中 $[P]$ 是<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BD%9B%E6%A3%AE%E6%8B%AC%E5%8F%B7">艾佛森括號</a>。</p><p>可以發現我們要計算不同的 $f(i)$ 差別都只在於最右邊的 $\text{&lt; }i$。此外，假設有兩個人編號 $x &lt; y$，如果分成 $g$ 人一組時 $x$ 會變成邊緣人，那麼 $y$ 也會在分成 $g$ 人一組時變成邊緣人。因此對於所有的分組，假設 $g$ 人一組，我們都要找到最後一組 (第 $\lfloor \frac{n}{g} \rfloor$ 組) 的最後一個人 (編號為 $\lfloor \frac{n}{g} \rfloor \cdot g$ )，將他後面的所有人的邊緣值都 $+1$，可以運用差分的技巧 $O(1)$ 做區間加值。</p><p>另外一個關鍵是左邊的 $d = \lfloor \frac{n}{g} \rfloor$ 只有 $O(\sqrt{n})$ 種不同的取值。我們可以運用<a href="https://oi-wiki.org/math/number-theory/sqrt-decomposition/">數論分塊</a>的技巧，其中最小的 $b$ 使得 $\lfloor \frac{n}{a}\rfloor &lt; \lfloor \frac{n}{b} \rfloor$ 就是 $b = \lfloor \frac{n}{\lfloor \frac{n}{a} \rfloor} \rfloor + 1$。因此，我們可以從 $a = 1$ 掃過 $O(\sqrt{n})$ 種 $\lfloor \frac{n}{a} \rfloor$ 不同的塊後到達 $n$。<br>同時，$x \in [L^\prime, R^\prime]$ 且 $\lfloor \frac{n}{L^\prime} \rfloor = \lfloor \frac{n}{R^\prime} \rfloor$ 的所有 $\lfloor \frac{n}{x} \rfloor \cdot x$ 會形成等差數列 (因為 $\lfloor \frac{n}{x} \rfloor$ 都相同，相鄰的 $x$ 只相差 $1$)。利用這個特性我們只需要紀錄每個區間的首項 $\lfloor \frac{n}{L^\prime} \rfloor \cdot L^\prime$，末項 $\lfloor \frac{n}{R^\prime} \rfloor \cdot R^\prime$，公差 $\lfloor \frac{n}{L^\prime} \rfloor$。</p><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>先找出所有 $[L^\prime, R^\prime]$，在題目要求的區間 $[L, R]$ 加上值。<br>$[L^\prime, R^\prime]$ 只有 $O(\sqrt{n})$ 個，且公差 $d$ 增加的很快 (其實就是<a href="https://zh.wikipedia.org/zh-tw/%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0">調和級數</a>)</p><p>時間複雜度為：$O(\sqrt{n} + (R - L) \log{\sqrt{n}})$</p><details><summary>Solution Code</summary><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> N, L, R;<br>cin &gt;&gt; N &gt;&gt; L &gt;&gt; R;<br>vector&lt;tuple&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;&gt; seg;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= N;) {<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> p = N / i;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> j = N / p + <span class="hljs-number">1</span>;<br>seg.<span class="hljs-built_in">emplace_back</span>(i * p + <span class="hljs-number">1</span>, (j - <span class="hljs-number">1</span>) * p + <span class="hljs-number">1</span>, p);<br>i = j;<br>}<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> OFFSET = L;<br><span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(R - L + <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [s, e, p] : seg) {<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> step = (s &lt; L ? (L - s + p - <span class="hljs-number">1</span>) / p : <span class="hljs-number">0</span>);<br>ans[L - OFFSET] += step;<br>s += step * p;<br><span class="hljs-keyword">while</span>(s &lt;= e &amp;&amp; s &lt;= R) {<br>ans[s - OFFSET] += <span class="hljs-number">1</span>;<br>s += p;<br>}<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; R - L + <span class="hljs-number">1</span>; ++i) {<br>ans[i] += ans[i - <span class="hljs-number">1</span>];<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; R - L + <span class="hljs-number">1</span>; ++i) {<br>cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">" \n"</span>[i == R - L];<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 數論分塊 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【題解】ABC256 A~H</title>
      <link href="/posts/abc256/"/>
      <url>/posts/abc256/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這次在賽後補完了 F、G、H，覺得題目不錯，所以來寫個題解吧</p><h2 id="A-2-N"><a href="#A-2-N" class="headerlink" title="A - 2^N"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_a">A - 2^N</a></h2><p>直接乘以 $n$ 次，或是使用 $&lt;&lt;$ 的位元運算。</p><p>時間複雜度：$O(n)$ 或 $O(1)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/32694745">Solution Code</a></p><h2 id="B-Batters"><a href="#B-Batters" class="headerlink" title="B - Batters"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_b">B - Batters</a></h2><p>從索引比較高的往回更新。</p><p>時間複雜度：$O(n)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/32694755">Solution Code</a></p><h2 id="C-Filling-3x3-array"><a href="#C-Filling-3x3-array" class="headerlink" title="C - Filling 3x3 array"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_c">C - Filling 3x3 array</a></h2><p>枚舉左上角四格的所有組合，並判斷剩下的數字是否合理。</p><p>時間複雜度：$O(30^4)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/32694818">Solution Code</a></p><h2 id="D-Union-of-Interval"><a href="#D-Union-of-Interval" class="headerlink" title="D - Union of Interval"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_d">D - Union of Interval</a></h2><p>對線段的左端點排序，判斷與下一個線段有無相交。若有重疊則進行合併。</p><p>時間複雜度：$O(n \log n)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/32694847">Solution Code</a></p><h2 id="E-Takahashi’s-Anguish"><a href="#E-Takahashi’s-Anguish" class="headerlink" title="E - Takahashi’s Anguish"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_e">E - Takahashi’s Anguish</a></h2><p>考慮一張無向圖 $G$，節點代表 $n$ 個人，我們連接邊 $i \leftrightarrow X_i$ 代表 $i$ 比 $X_i$ 早拿到禮物。因此如果圖中存在環，代表拿到禮物的先後順序矛盾。因此，題目可化簡為在 $G$ 加入一些邊，使得這些邊不會形成環且權重和越大(代表我們避免掉越多的 frustration)，剩下的邊的權重和(無法避免掉的)就是題目所求。因此，我們可以用並查集維護無向圖中的連通塊，並把邊按照權重由大到小嘗試加入 $G$。</p><p>時間複雜度：$O(n \alpha(n))$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/37711907">Solution Code</a></p><h2 id="F-Cumulative-Cumulative-Cumulative-Sum"><a href="#F-Cumulative-Cumulative-Cumulative-Sum" class="headerlink" title="F - Cumulative Cumulative Cumulative Sum"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_f">F - Cumulative Cumulative Cumulative Sum</a></h2><p>先來將 $A, B, C$ 數列展開觀察</p><table><thead><tr><th align="center"></th><th align="center">i = 1</th><th align="center">i = 2</th><th align="center">i = 3</th><th align="center">i = 4</th></tr></thead><tbody><tr><td align="center">$A$</td><td align="center">$A_1$</td><td align="center">$A_2$</td><td align="center">$A_3$</td><td align="center">$A_4$</td></tr><tr><td align="center">$B$</td><td align="center">$A_1$</td><td align="center">$A_1 + A_2$</td><td align="center">$A_1 + A_2 + A_3$</td><td align="center">$A_1 + A_2 + A_3 + A_4$</td></tr><tr><td align="center">$C$</td><td align="center">$A_1$</td><td align="center">$2 \cdot A_1 + A_2$</td><td align="center">$3 \cdot A_1 + 2 \cdot A_2 + A_3$</td><td align="center">$4 \cdot A_1 + 3 \cdot A_2 + 2 \cdot A_3 + A_4$</td></tr></tbody></table><p>所要求的 $D_x$ 就是 $C$ 的前綴和 $\sum\limits_{i = 1}^x C_i$<br>而 $C$ 數列有個特性，當我們將 $A_i$ 增加 $K$，$A_{i + 1}$ 要增加 $2K$，$A_{i + 2}$ 增加 $3K$，以此類推。因此我們需要可以區間更新和區間加總的資料結構，可以用線段樹 + 懶人標記。簡化到這裡可以發現就跟<a href="https://cses.fi/problemset/task/1736">這題</a>一模一樣。</p><p>時間複雜度：$O(n \log n)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/37712082">Solution Code</a></p><h2 id="G-Black-and-White-Stones"><a href="#G-Black-and-White-Stones" class="headerlink" title="G - Black and White Stones"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_g">G - Black and White Stones</a></h2><p>每個邊有 $d + 1$ 顆石頭。把每個邊的狀態列出來，可以發現一共有四種狀態：白頭白尾、白頭黑尾、黑頭白尾、黑頭黑尾。如果把狀態寫成矩陣：</p><p>\begin{bmatrix}<br>  C_{WW} &amp; C_{WB} \\<br>  C_{BW} &amp; C_{BB}<br>\end{bmatrix}</p><p>把 $n$ 條邊串在一起就是將矩陣相乘 $n$ 次，可以使用<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E6%B1%82%E5%B9%82">矩陣快速冪</a>在 $O(\log n)$ 完成運算。由於第一邊個的頭和第 $n$ 個邊的尾必須相同(圖形為 $n$ 邊形)，對答案的貢獻為 $C_{WW} + C_{BB}$<br>利用上述的技巧，枚舉白石的數量 $W$，對應的矩陣為：</p><p>\begin{bmatrix}<br>  \binom{d - 1}{W - 2} &amp; \binom{d - 1}{W - 1} \\<br>  \binom{d - 1}{W - 1} &amp; \binom{d - 1}{W}<br>\end{bmatrix}</p><p>時間複雜度：$O(d \log n)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/38152274">Solution Code</a></p><h2 id="Ex-I-like-Query-Problem"><a href="#Ex-I-like-Query-Problem" class="headerlink" title="Ex - I like Query Problem"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_h">Ex - I like Query Problem</a></h2><p>第二種操作：區間改值，可以運用線段樹 + 懶人標記 $O(\log n)$ 更新。</p><p>第一種操作：這是本題最難的地方，由於更新後的加總無法直接計算出來，我們只能分段更新。把 $[L, R + 1)$ 拆成很多小區間 $[L, s_1), [s_1, s_2), [s_2, s_3), \dots [s_k, R + 1)$ 使得每一個小區間的數值都相同。這樣就能套用區間改值，把每個區間更新成 $\lfloor \frac{A_{s_i}}{x}\rfloor$。</p><p>接下來我們要分析第一種操作的時間複雜度。在切成小區間時，只有包含最左邊和最右邊數值的兩個區間有可能被切開變成新的小區間。因此，我們最多有 $O(n + q)$ 個小區間。而對於一個小區間，能夠被除的次數不會超過 $O(\log \max(A))$ 次，所以總操作次數的上限為 $O((n + q) \log \max(A))$。而因為單一操作 (區間改值) 的時間複雜度為 $O(\log n)$，整體的時間複雜度為 $O((n + q) \log n \log \max (A))$</p><p>第一種操作還能優化，改成分成很多個區間 $P_1, P_2, \dots P_K$ 使得 $\lfloor \frac{\min(P_i)}{x} \rfloor = \lfloor \frac{\max(P_i)}{x} \rfloor$，這樣區間的總數會更少，常數會比較小。</p><p><a href="https://atcoder.jp/contests/abc256/submissions/37712592">Solution Code</a></p>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 線段樹 </tag>
            
            <tag> 矩陣快速冪 </tag>
            
            <tag> 並查集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
