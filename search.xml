<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Aliens 優化應用</title>
      <link href="/2023/03/01/Aliens-Optimization/"/>
      <url>/2023/03/01/Aliens-Optimization/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>有些題目要求進行 $k$ 次操作的最大/最小值。我們開心的列出 $dp[i][j]$ 為前 $i$ 個東西進行 $j$ 次操作的最大值，答案就是 $dp[n][k]$，但很不幸的 $O(nk)$ 會爆，因此我們要換個做法。</p><p><strong>Definition.</strong> 函數 $f(k)$ 為進行 $k$ 次操作的最大值。</p><p>$f(k)$ 必須是一個凹函數 (concave function) 才能套用 Aliens 優化 (如果改成最小值的話則必須是凸函數)。凹函數的斜率非嚴格遞減，也就是說每多進行一次操作，數值增加的幅度會越來越少。</p><p>$$f(k + 1) - f(k) \leq f(k) - f(k - 1)$$</p><p><strong>Definition.</strong> 函數 $g_p(k) = f(k) - kp$。</p><p>$g_p(k)$ 可以想像成對於每筆操作，我們額外收取 $p$ 元的手續費。不難看出 $g_p(k)$ 也會是一個凹函數，因為</p><p>\begin{aligned}<br>g_p(k + 1) - g_p(k) &amp;= (f(k + 1) - (k + 1)p) - (f(k) - kp) \\<br>&amp;= f(k + 1) - f(k) - p \\<br>&amp; \leq f(k) - f(k - 1) - p \\<br>&amp;= (f(k) - kp) - (f(k - 1) - (k - 1)p) \\<br>&amp;= g_p(k) - g_p(k - 1) \\<br>\iff g_p(k + 1) - g_p(k) &amp; \leq g_p(k) - g_p(k - 1)<br>\end{aligned}</p><p>當 $p$ 越大，$g_p(k)$ 最大值發生的位置 $k$ 會越往左邊靠 (可以想成手續費太貴，所以不進行那麼多次操作)，當 $p$ 越小，最大值發生的位置會越往右靠 (手續費太便宜，多進行幾次操作不會虧錢)。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="可以參考 Reference 1. 的 gif，其中藍色的函數就是 $g_p(k)$。">[1]</span></a></sup></p><p>有了以上的概念，我們就可以對 $p$ 進行二分搜，讓 $g_p(k)$ 最大值發生的位置剛好落在 $k$，也就是操作 $k$ 次，這樣我們就可以回頭算出 $f(k) = g_p(k) + kp$ 了！如果 $f(k)$ 的定義改成最小值的話就改成 $g_p(k) = f(k) + kp$，也能用同樣的邏輯求出。</p><p>其他實作的細節可以參考 <a href="#Reference">Reference</a> 的文章。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>找最小值的話記得把 $+kp$ 改成 $-kp$。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 找最大值</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Aliens</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> l, <span class="hljs-type">long</span> <span class="hljs-type">long</span> r, <span class="hljs-type">int</span> k, Func f)</span> </span>{<br><span class="hljs-keyword">while</span>(l &lt; r) {<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> [score, op] = <span class="hljs-built_in">f</span>(m);<br><span class="hljs-keyword">if</span>(op == k) {<br><span class="hljs-keyword">return</span> score + m * k;<br>}<br><span class="hljs-keyword">if</span>(op &lt; k) {<br>r = m;<br>} <span class="hljs-keyword">else</span> {<br>l = m + <span class="hljs-number">1</span>;<br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(l).first + l * k;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="例題"><a href="#例題" class="headerlink" title="例題"></a>例題</h2><p>底下的例題 $dp$ 應該要是 {最大/最小值, 最少操作次數}，方便起見只寫最大/最小值，實作時記得要計算操作次數。$\Phi$ 為每筆操作而外收的手續費。</p><blockquote><p><a href="https://tioj.ck.tp.edu.tw/problems/2039">AI-666 賺多少</a></p><p>已知 $n$ 個時間點股票的價格，手上沒有股票的話才能買入，有股票才能賣出。求買賣 $k$ 次的最大利益？</p></blockquote><p>本題有 greedy 解，但我們練習用 Aliens 優化來做。</p><p>定義 $f(k)$ 為做 $k$ 次交易的最大收益。可以觀察到 $f$ 是凹函數，因為如果第 $k$ 筆交易的獲益比第 $k - 1$ 次多，我們可以交換交易的順序，把 $k - 1$ 多做的那次換成 $k$ 多做的那次。</p><p>定義 $dp$：</p><ul><li>$dp_0[i]$ = 時間 $i$ 時手上<strong>沒有</strong>股票的最大收益</li><li>$dp_1[i]$ = 時間 $i$ 時手上<strong>持有</strong>股票的最大收益</li></ul><p>轉移就會是：</p><p>\begin{aligned}<br>dp_0[i] &amp;= \max(dp_0[i - 1], dp_1[i - 1] + a[i] - \Phi) \\<br>dp_1[i] &amp;= \max(dp_1[i - 1], dp_0[i - 1] - a[i])<br>\end{aligned}</p><p>計算一次 $dp$ 的時間為 $O(n)$，因此總時間複雜度為 $O(n \log C)$ (以下皆用 $C$ 表示 Aliens 二分搜的範圍)。</p><details><summary>Solution Code</summary><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// find maximum</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Aliens</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> l, <span class="hljs-type">long</span> <span class="hljs-type">long</span> r, <span class="hljs-type">int</span> k, Func f)</span> </span>{<br><span class="hljs-keyword">while</span>(l &lt; r) {<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> [score, op] = <span class="hljs-built_in">f</span>(m);<br><span class="hljs-keyword">if</span>(op == k) {<br><span class="hljs-keyword">return</span> score + m * k;<br>}<br><span class="hljs-keyword">if</span>(op &lt; k) {<br>r = m;<br>} <span class="hljs-keyword">else</span> {<br>l = m + <span class="hljs-number">1</span>;<br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(l).first + l * k;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n, k;<br>cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>cin &gt;&gt; a[i];<br>}<br><span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">long</span> <span class="hljs-type">long</span> p) {<br>pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; dp0 = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>};<br>pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; dp1 = {INT_MIN, <span class="hljs-number">0</span>};<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; new_dp0 = <span class="hljs-built_in">max</span>(dp0, pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;{dp1.first + a[i] - p, dp1.second - <span class="hljs-number">1</span>});<br>pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; new_dp1 = <span class="hljs-built_in">max</span>(dp1, pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;{dp0.first - a[i], dp0.second});<br><span class="hljs-built_in">swap</span>(dp0, new_dp0);<br><span class="hljs-built_in">swap</span>(dp1, new_dp1);<br>}<br>dp0.second = -dp0.second;<br><span class="hljs-keyword">return</span> dp0;<br>};<br>cout &lt;&lt; <span class="hljs-built_in">Aliens</span>(<span class="hljs-number">0</span>, (<span class="hljs-type">int</span>) <span class="hljs-number">1e8</span>, k, f) &lt;&lt; <span class="hljs-string">"\n"</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></details><blockquote><p><a href="https://cses.fi/problemset/task/2086">CSES - Subarray Squares</a></p><p>把長度為 $n$ 的數列切成 $k$ 段，一段的費用是和的平方，求最小費用和？</p></blockquote><p>定義 $f(k)$ 為切成 $k$ 段的最小費用和。固定切割的位置，切割的先後順序不會影響答案，我們可以讓影響最小的那次切割作為第 $k$ 次，因此 $f$ 是一個凸函數。</p><p>定義 $dp[i]$ 為只考慮前 $i$ 個數字的最小費用和，轉移就會是：</p><p>$$dp[i] = \min_{j \leq i} (dp[j - 1] + (\sum_{k = j}^{i} a[i])^2 + \Phi)$$</p><p>注意轉移裡的 $\Phi$ 係數為正，因為我們的目標是找最小值。</p><p>時間複雜度：$O(n^2 \log C)$</p><details><summary>Solution Code</summary><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// find minimum</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Func&gt;</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Aliens</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> l, <span class="hljs-type">long</span> <span class="hljs-type">long</span> r, <span class="hljs-type">int</span> k, Func f)</span> </span>{<br><span class="hljs-keyword">while</span>(l &lt; r) {<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> [score, op] = <span class="hljs-built_in">f</span>(m);<br><span class="hljs-keyword">if</span>(op == k) {<br><span class="hljs-keyword">return</span> score - m * k;<br>}<br><span class="hljs-keyword">if</span>(op &lt; k) {<br>r = m;<br>} <span class="hljs-keyword">else</span> {<br>l = m + <span class="hljs-number">1</span>;<br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(l).first - l * k;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n, k;<br>cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>cin &gt;&gt; a[i];<br>}<br><span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">pref</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>pref[i + <span class="hljs-number">1</span>] = pref[i] + a[i];<br>}<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> INF = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) <span class="hljs-number">1e18</span>L + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">long</span> <span class="hljs-type">long</span> cost) -&gt; pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; {<br>vector&lt;pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;{INF, <span class="hljs-number">0</span>});<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; --j) {<br><span class="hljs-keyword">auto</span> cur = (j &gt; <span class="hljs-number">0</span> ? dp[j - <span class="hljs-number">1</span>] : pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;{<span class="hljs-number">0</span>, <span class="hljs-number">0</span>});<br>cur.first += (pref[i + <span class="hljs-number">1</span>] - pref[j]) * (pref[i + <span class="hljs-number">1</span>] - pref[j]) + cost;<br>cur.second += <span class="hljs-number">1</span>;<br>dp[i] = <span class="hljs-built_in">min</span>(dp[i], cur);<br>}<br>}<br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>};<br>cout &lt;&lt; <span class="hljs-built_in">Aliens</span>(<span class="hljs-number">0</span>, INF, k, f) &lt;&lt; <span class="hljs-string">"\n"</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></details><h2 id="習題"><a href="#習題" class="headerlink" title="習題"></a>習題</h2><p><a href="https://zerojudge.tw/ShowProblem?problemid=h926">ZJ - 美食博覽會 (k 值加大版)</a><br><a href="https://cses.fi/problemset/task/2087/">CSES - Houses and Schools</a><br><a href="https://codeforces.com/contest/1279/problem/F">CF - New Year and Handle Change</a><br><a href="https://tioj.ck.tp.edu.tw/problems/1986">TIOJ - 郵局設置問題 $\infty$ EXTREME</a><br><a href="https://ioinformatics.org/files/ioi2016problem6.pdf">IOI 2016 - Aliens</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://cp.wiwiho.me/aliens/">[WiwiHo 的競程筆記] Aliens 優化</a></li><li><a href="https://tioj.ck.tp.edu.tw/uploads/attachment/5/51/10.pdf">[2016建中校內培訓講義] Aliens 優化</a></li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>可以參考 Reference 1. 的 gif，其中藍色的函數就是 $g_p(k)$。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 演算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aliens 優化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1780F Three Chairs 題解</title>
      <link href="/2023/01/27/Codeforces-1780F-Editorial/"/>
      <url>/2023/01/27/Codeforces-1780F-Editorial/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1780/problem/F">題目連結</a></p><h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><p>給定一個長度為 $n$ 的數列 $a$，求：</p><p>$$\sum_{i = 0}^{n - 1} \sum_{j = i + 1}^{n - 1} \sum_{k = j + 1}^{n - 1} [\gcd(\min(a_i, a_j, a_k), \max(a_i, a_j, a_k)) = 1]$$</p><p>其中 $[P]$ 是<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BD%9B%E6%A3%AE%E6%8B%AC%E5%8F%B7">艾佛森括號</a>。</p><ul><li>$3 \leq n \leq 3 \cdot 10^5$</li><li>$1 \leq a_i \leq 3 \cdot 10^5$</li><li>$a_i \neq a_j, i \neq j$</li></ul><h2 id="觀察"><a href="#觀察" class="headerlink" title="觀察"></a>觀察</h2><p>$\mu$ 為<a href="https://oi-wiki.org/math/number-theory/mobius/">莫比烏斯函數</a>，具有以下的性質：<br>$$<br>\sum_{d | n} \mu(d) = [n = 1] =<br>\begin{cases}<br>    0 &amp; n \neq 1 \\<br>    1 &amp; n = 1<br>\end{cases}<br>$$</p><p>我們令 $A = \max(a)$ 為值域。<br>利用莫比烏斯函數的性質，我們可以把原本的式子轉換為：</p><p>$$<br>\begin{aligned}<br>&amp;= \sum_{i = 0}^{n - 1} \sum_{j = i + 1}^{n - 1} \sum_{k = j + 1}^{n - 1} \sum_{d | \gcd(\min(a_i, a_j, a_k), \max(a_i, a_j, a_k))} \mu(d) \\<br>&amp;= \sum_{d = 1}^{A} \mu(d) \sum_{i = 0}^{n - 1} \sum_{j = i + 1}^{n - 1} \sum_{k = j + 1}^{n - 1} ([d | \min(a_i, a_j, a_k)][d | \max(a_i, a_j, a_k)])<br>\end{aligned}<br>$$</p><p>可以發現後面那項其實就是在求有幾組 $i &lt; j &lt; k$ 滿足 $a_i &lt; a_j &lt; a_k$ 且 $a_i$ 和 $a_k$ 是 $d$ 的倍數，枚舉 $d$ 的倍數後可以輕易求出。</p><p>莫比烏斯函數可以用<a href="https://oi-wiki.org/math/number-theory/sieve/#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95">線性篩</a>在 $O(A)$ 求出，而所有倍數的個數為 $\sum_{d = 1}^{A} \lfloor \frac{A}{d} \rfloor \approx O(A \log A)$，總時間複雜度為 $O(n + A \log A)$。</p><p><a href="https://codeforces.com/contest/1780/submission/190633405">Solution Code</a></p>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比烏斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSES - One Bit Positions 題解</title>
      <link href="/2023/01/04/CSES-One-Bit-Positions-Editorial/"/>
      <url>/2023/01/04/CSES-One-Bit-Positions-Editorial/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cses.fi/problemset/task/2112/">題目連結</a></p><h2 id="題解"><a href="#題解" class="headerlink" title="題解"></a>題解</h2><p>先將字串轉換成多項式的形式表示($\text{“10011”} \to 1x^0 + 0x^1 + 0x^2 + 1x^3 + 1x^4$)。<br>假設轉換成多項式 $a = \sum_{i = 0}^{n - 1} a_i \cdot x^i$，我們要求的是對於所有 $1 \leq k \leq n - 1$，$\sum_{i - j = k} a_i \cdot a_j$。<br>可以觀察到如果 $i - j = k$，那麼 $i + (n - 1 - j) = n - 1 + k$。<br>建立 $a^\prime = \sum_{i = 0}^{n - 1} a_{n - 1 - i} \cdot x^i$，答案就會是多項式 $a$ 和 $a^\prime$ 的卷積 $P$，$k$ 的答案即為$[x^{n - 1 + k}]P$。<br>由於 $n \leq 10^5$，$O(n^2)$ 的多項式卷積會 TLE，可以使用 <a href="https://oi-wiki.org/math/poly/fft/">FFT</a> 或是 <a href="https://oi-wiki.org/math/poly/ntt/">NTT</a> 在 $O(n \log n)$ 求出。</p><details><summary>Solution Code</summary><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> cd = complex&lt;<span class="hljs-type">double</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>); <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(vector&lt;cd&gt;&amp; a, <span class="hljs-type">bool</span> inv)</span> </span>{<br><span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) a.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br><span class="hljs-type">int</span> bit = n &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(; j &amp; bit; bit &gt;&gt;= <span class="hljs-number">1</span>) {<br>j ^= bit;<br>}<br>j ^= bit;<br><span class="hljs-keyword">if</span>(i &lt; j) {<br><span class="hljs-built_in">swap</span>(a[i], a[j]);<br>}<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len &lt;&lt;= <span class="hljs-number">1</span>) {<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ang = <span class="hljs-number">2</span> * PI / len * (inv ? <span class="hljs-number">-1</span> : +<span class="hljs-number">1</span>);<br><span class="hljs-function">cd <span class="hljs-title">rot</span><span class="hljs-params">(cos(ang), sin(ang))</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += len) {<br><span class="hljs-function">cd <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len / <span class="hljs-number">2</span>; ++j) {<br>cd u = a[i + j], v = a[i + j + len / <span class="hljs-number">2</span>] * w;<br>a[i + j] = u + v;<br>a[i + j + len / <span class="hljs-number">2</span>] = u - v;<br>w *= rot;<br>}<br>}<br>}<br><span class="hljs-keyword">if</span>(inv) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x : a) {<br>x /= n;<br>}<br>}<br>}<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br><span class="hljs-function">vector&lt;cd&gt; <span class="hljs-title">fa</span><span class="hljs-params">(a.begin(), a.end())</span></span>;<br><span class="hljs-function">vector&lt;cd&gt; <span class="hljs-title">fb</span><span class="hljs-params">(b.begin(), b.end())</span></span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n &lt; (<span class="hljs-type">int</span>) a.<span class="hljs-built_in">size</span>() + (<span class="hljs-type">int</span>) b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {<br>n &lt;&lt;= <span class="hljs-number">1</span>;<br>}<br>fa.<span class="hljs-built_in">resize</span>(n);<br>fb.<span class="hljs-built_in">resize</span>(n);<br><span class="hljs-built_in">FFT</span>(fa, <span class="hljs-literal">false</span>);<br><span class="hljs-built_in">FFT</span>(fb, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>fa[i] *= fb[i];<br>}<br><span class="hljs-built_in">FFT</span>(fa, <span class="hljs-literal">true</span>);<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(a.size() + b.size() - <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>) c.<span class="hljs-built_in">size</span>(); ++i) {<br>c[i] = <span class="hljs-built_in">round</span>(fa[i].<span class="hljs-built_in">real</span>());<br>}<br><span class="hljs-keyword">return</span> c;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>string s;<br>cin &gt;&gt; s;<br><span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) s.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>a[i] = b[n - <span class="hljs-number">1</span> - i] = s[i] - <span class="hljs-string">'0'</span>;<br>}<br><span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">multiply</span>(a, b);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) {<br>cout &lt;&lt; c[n - <span class="hljs-number">1</span> + i] &lt;&lt; <span class="hljs-string">" \n"</span>[i == n - <span class="hljs-number">1</span>];<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> CSES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPSC 2020 pA 邊緣人 題解</title>
      <link href="/2022/08/02/NPSC-2020-pA-Editorial/"/>
      <url>/2022/08/02/NPSC-2020-pA-Editorial/</url>
      
        <content type="html"><![CDATA[<p><a href="https://contest.cc.ntu.edu.tw/npsc2020/teamclient/semi_senior.pdf">題目連結</a></p><h2 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h2><p>NPSC 是我參加的第一場比賽，理所當然的被打爆，只解出最水的pB。當時跟隊友花了很多時間在解這題，但是由於數學知識不足，都在原地打轉。最近剛好翻到這題，想說花點時間想一下，馬上就有了突破，也順利 $\color{green}{\text{AC}}$，算是彌補了當時的遺憾。</p><h2 id="題目敘述"><a href="#題目敘述" class="headerlink" title="題目敘述"></a>題目敘述</h2><p>有 $n$ 個人要分組，一組 $x$ 個人，編號 $1$ 到 $x$ 的人會分到一組，$(x + 1)$ 到 $2x$ 會分到一組，依此類推。最後可能會有一些人組員人數不足 $x$，我們稱這些人為邊緣人。我們定義編號 $i$ 的人的邊緣值 $f(i)$ 為：在 $x = 1, x = 2, \dots , x = n$ 這 $n$ 個情況中，編號 $i$ 的人成為邊緣人的情況總數。<br>給定 $L, R$，請求出 $f(L), f(L + 1), \dots , f(R)$。</p><ul><li>$1 \leq n \leq 2^{40}$</li><li>$L \leq R \leq n$</li><li>$R − L \leq 3 \cdot 10^5$</li></ul><h2 id="觀察"><a href="#觀察" class="headerlink" title="觀察"></a>觀察</h2><p>$f(i)$ 可以改寫為：</p><p>$$f(i) = \sum_{g = 1}^n [\lfloor \frac{n}{g} \rfloor \cdot g &lt; i]$$</p><p>其中 $[P]$ 是<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BD%9B%E6%A3%AE%E6%8B%AC%E5%8F%B7">艾佛森括號</a>。</p><p>可以發現我們要計算不同的 $f(i)$ 差別都只在於最右邊的 $\text{&lt; }i$。此外，假設有兩個人編號 $x &lt; y$，如果分成 $g$ 人一組時 $x$ 會變成邊緣人，那麼 $y$ 也會在分成 $g$ 人一組時變成邊緣人。因此對於所有的分組，假設 $g$ 人一組，我們都要找到最後一組 (第 $\lfloor \frac{n}{g} \rfloor$ 組) 的最後一個人 (編號為 $\lfloor \frac{n}{g} \rfloor \cdot g$ )，將他後面的所有人的邊緣值都 $+1$，可以運用差分的技巧 $O(1)$ 做區間加值。</p><p>另外一個關鍵是左邊的 $d = \lfloor \frac{n}{g} \rfloor$ 只有 $O(\sqrt{n})$ 種不同的值。如果有辦法快速的掃過所有的 $d$，那對本題有很大的幫助。我們可以運用<a href="https://oi-wiki.org/math/number-theory/sqrt-decomposition/">數論分塊</a>的技巧，其中最小的 $b$ 使得 $\lfloor \frac{n}{a}\rfloor &lt; \lfloor \frac{n}{b} \rfloor$ 就是 $\lfloor \frac{n}{\lfloor \frac{n}{a} \rfloor} \rfloor + 1$。因此，我們可以從 $a = 1$ 在經過 $O(\sqrt{n})$ 個值後到達 $n$。<br>同時，$x \in [L’, R’]$ 且 $\lfloor \frac{n}{L’} \rfloor = \lfloor \frac{n}{R’} \rfloor$ 的所有 $\lfloor \frac{n}{x} \rfloor \cdot x$ 會形成等差數列 (因為 $\lfloor \frac{n}{x} \rfloor$ 都相同，相鄰的 $x$ 只相差 $1$)。利用這個特性我們只需要紀錄每個區間的首項 $\lfloor \frac{n}{L’} \rfloor \cdot L’$，末項 $\lfloor \frac{n}{R’} \rfloor \cdot R’$，公差 $\lfloor \frac{n}{L’} \rfloor$。</p><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>先找出所有 $[L’, R’]$，在題目要求的區間 $[L, R]$ 加上值<br>$[L’, R’]$ 只有 $O(\sqrt{n})$ 個，且公差 $d$ 增加的很快 (其實就是<a href="https://zh.wikipedia.org/zh-tw/%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0">調和級數</a>)</p><p>時間複雜度為：$O(\sqrt{n} + (R - L) \log \sqrt{n})$</p><details><summary>Solution Code</summary><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> N, L, R;<br>cin &gt;&gt; N &gt;&gt; L &gt;&gt; R;<br>vector&lt;tuple&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;&gt; seg;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= N;) {<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> p = N / i;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> j = N / p + <span class="hljs-number">1</span>;<br>seg.<span class="hljs-built_in">emplace_back</span>(i * p + <span class="hljs-number">1</span>, (j - <span class="hljs-number">1</span>) * p + <span class="hljs-number">1</span>, p);<br>i = j;<br>}<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> OFFSET = L;<br><span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(R - L + <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [s, e, p] : seg) {<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> step = (s &lt; L ? (L - s + p - <span class="hljs-number">1</span>) / p : <span class="hljs-number">0</span>);<br>ans[L - OFFSET] += step;<br>s += step * p;<br><span class="hljs-keyword">while</span>(s &lt;= e &amp;&amp; s &lt;= R) {<br>ans[s - OFFSET] += <span class="hljs-number">1</span>;<br>s += p;<br>}<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; R - L + <span class="hljs-number">1</span>; ++i) {<br>ans[i] += ans[i - <span class="hljs-number">1</span>];<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; R - L + <span class="hljs-number">1</span>; ++i) {<br>cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">" \n"</span>[i == R - L];<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 數論分塊 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 256 A~H 題解</title>
      <link href="/2022/06/25/ABC-256-Editorial/"/>
      <url>/2022/06/25/ABC-256-Editorial/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這次在賽後補完了F、G、H，覺得題目不錯，所以來寫個題解吧</p><h2 id="A-2-N"><a href="#A-2-N" class="headerlink" title="A - 2^N"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_a">A - 2^N</a></h2><p>直接乘以 $n$ 次，或是使用 $&lt;&lt;$ 的位元運算。</p><p>時間複雜度：$O(n)$ 或 $O(1)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/32694745">Solution Code</a></p><h2 id="B-Batters"><a href="#B-Batters" class="headerlink" title="B - Batters"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_b">B - Batters</a></h2><p>從索引比較高的往回更新。</p><p>時間複雜度：$O(n)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/32694755">Solution Code</a></p><h2 id="C-Filling-3x3-array"><a href="#C-Filling-3x3-array" class="headerlink" title="C - Filling 3x3 array"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_c">C - Filling 3x3 array</a></h2><p>枚舉左上角四格的所有組合，並判斷剩下的數字是否合理。</p><p>時間複雜度：$O(30^4)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/32694818">Solution Code</a></p><h2 id="D-Union-of-Interval"><a href="#D-Union-of-Interval" class="headerlink" title="D - Union of Interval"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_d">D - Union of Interval</a></h2><p>對線段的左端點排序，判斷與下一個線段有無相交。若有重疊則進行合併。</p><p>時間複雜度：$O(n \log n)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/32694847">Solution Code</a></p><h2 id="E-Takahashi’s-Anguish"><a href="#E-Takahashi’s-Anguish" class="headerlink" title="E - Takahashi’s Anguish"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_e">E - Takahashi’s Anguish</a></h2><p>考慮一張無向圖 $G$，節點代表 $n$ 個人，我們連接邊 $i \leftrightarrow X_i$ 代表 $i$ 比 $X_i$ 早拿到禮物。因此如果圖中存在環，代表拿到禮物的先後順序矛盾。因此，題目可化簡為在 $G$ 加入一些邊，使得這些邊不會形成環且權重和越大(代表我們避免掉越多的 frustration)，剩下的邊的權重和(無法避免掉的)就是題目所求。因此，我們可以用並查集維護無向圖中的連通塊，並把邊按照權重由大到小嘗試加入 $G$。</p><p>時間複雜度：$O(n \alpha(n))$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/37711907">Solution Code</a></p><h2 id="F-Cumulative-Cumulative-Cumulative-Sum"><a href="#F-Cumulative-Cumulative-Cumulative-Sum" class="headerlink" title="F - Cumulative Cumulative Cumulative Sum"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_f">F - Cumulative Cumulative Cumulative Sum</a></h2><p>先來將 $A, B, C$ 數列展開觀察</p><table><thead><tr><th></th><th>i = 1</th><th>i = 2</th><th>i = 3</th><th>i = 4</th></tr></thead><tbody><tr><td>$A$</td><td>$A_1$</td><td>$A_2$</td><td>$A_3$</td><td>$A_4$</td></tr><tr><td>$B$</td><td>$A_1$</td><td>$A_1 + A_2$</td><td>$A_1 + A_2 + A_3$</td><td>$A_1 + A_2 + A_3 + A_4$</td></tr><tr><td>$C$</td><td>$A_1$</td><td>$2 \cdot A_1 + A_2$</td><td>$3 \cdot A_1 + 2 \cdot A_2 + A_3$</td><td>$4 \cdot A_1 + 3 \cdot A_2 + 2 \cdot A_3 + A_4$</td></tr></tbody></table><p>所要求的 $D_x$ 就是 $C$ 的前綴和 $\sum_{i = 1}^x C_i$<br>而 $C$ 數列有個特性，當我們將 $A_i$ 增加 $K$，$A_{i + 1}$ 要增加 $2K$，$A_{i + 2}$ 增加 $3K$，以此類推。因此我們需要可以區間更新和區間加總的資料結構，可以用線段樹 + 懶人標記。簡化到這裡可以發現就跟<a href="https://cses.fi/problemset/task/1736">這題</a>一模一樣。</p><p>時間複雜度：$O(n \log n)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/37712082">Solution Code</a></p><h2 id="G-Black-and-White-Stones"><a href="#G-Black-and-White-Stones" class="headerlink" title="G - Black and White Stones"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_g">G - Black and White Stones</a></h2><p>每個邊有 $d + 1$ 顆石頭。把每個邊的狀態列出來，可以發現一共有四種狀態：白頭白尾、白頭黑尾、黑頭白尾、黑頭黑尾。如果把狀態寫成矩陣：</p><p>\begin{bmatrix}<br>  C_{WW} &amp; C_{WB} \\<br>  C_{BW} &amp; C_{BB}<br>\end{bmatrix}</p><p>把 $n$ 條邊串在一起就是將矩陣相乘 $n$ 次，可以使用<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E6%B1%82%E5%B9%82">矩陣快速冪</a>在 $O(\log n)$ 完成運算。由於第一邊個的頭和第 $n$ 個邊的尾必須相同(圖形為 $n$ 邊形)，對答案的貢獻為 $C_{WW} + C_{BB}$<br>利用上述的技巧，枚舉白石的數量 $W$，對應的矩陣為：</p><p>\begin{bmatrix}<br>  \binom{d - 1}{W - 2} &amp; \binom{d - 1}{W - 1} \\<br>  \binom{d - 1}{W - 1} &amp; \binom{d - 1}{W}<br>\end{bmatrix}</p><p>時間複雜度：$O(d \log n)$</p><p><a href="https://atcoder.jp/contests/abc256/submissions/38152274">Solution Code</a></p><h2 id="Ex-I-like-Query-Problem"><a href="#Ex-I-like-Query-Problem" class="headerlink" title="Ex - I like Query Problem"></a><a href="https://atcoder.jp/contests/abc256/tasks/abc256_h">Ex - I like Query Problem</a></h2><p>第二種操作：區間改值，可以運用線段樹 + 懶人標記 $O(\log n)$ 更新。</p><p>第一種操作：這是本題最難的地方，由於更新後的加總無法直接計算出來，我們只能分段更新。把 $[L, R + 1)$ 拆成很多小區間 $[L, s_1), [s_1, s_2), [s_2, s_3), \dots [s_k, R + 1)$ 使得每一個小區間的數值都相同。這樣就能套用區間改值，把每個區間更新成 $\lfloor \frac{A_{s_i}}{x}\rfloor$。</p><p>接下來我們要分析第一種操作的時間複雜度。在切成小區間時，只有包含最左邊和最右邊數值的兩個區間有可能被切開變成新的小區間。因此，我們最多有 $O(n + q)$ 個小區間。而對於一個小區間，能夠被除的次數不會超過 $O(\log \max(A))$ 次，所以總操作次數的上限為 $O((n + q) \log \max(A))$。而因為單一操作 (區間改值) 的時間複雜度為 $O(\log n)$，整體的時間複雜度為 $O((n + q) \log n \log \max (A))$</p><p>第一種操作還能優化，改成分成很多個區間 $P_1, P_2, \dots P_K$ 使得 $\lfloor \frac{\min(P_i)}{x} \rfloor = \lfloor \frac{\max(P_i)}{x} \rfloor$，這樣區間的總數會更少，常數會比較小。</p><p><a href="https://atcoder.jp/contests/abc256/submissions/37712592">Solution Code</a></p>]]></content>
      
      
      <categories>
          
          <category> 競程 </category>
          
          <category> 題解 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 線段樹 </tag>
            
            <tag> 矩陣快速冪 </tag>
            
            <tag> 並查集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
